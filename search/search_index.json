{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Astronomer Orbiter can land legacy workloads safely down in a new home on Apache Airflow! </p>"},{"location":"#what-is-orbiter","title":"What is Orbiter?","text":"<p>Orbiter is both a CLI and Framework for converting workflows from other orchestration tools to Apache Airflow.</p> <p>Generally it can be thoughts of as: <pre><code>flowchart LR\n    origin{{ XML/JSON/YAML/Etc Workflows }}\n    origin --&gt;| \u2728 Translations \u2728 | airflow{{ Apache Airflow Project }}</code></pre> The framework is a set of Rules and Objects that can translate workflows from an Origin system to an Airflow project.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the <code>orbiter</code> CLI, if you have Python &gt;= 3.10 installed via <code>pip</code>: <pre><code>pip install astronomer-orbiter\n</code></pre> If you do not have a compatible Python environment, pre-built binary executables of the <code>orbiter</code> CLI are available for download on the Releases page.</p>"},{"location":"#translate","title":"Translate","text":"<p>Utilize the <code>orbiter</code> CLI with existing translations to convert workflows from other systems to an Airflow project.</p> <ol> <li>Set up a new  <code>workflow/</code> folder. Add your workflows files to it <pre><code>.\n\u2514\u2500\u2500 workflow/\n    \u251c\u2500\u2500 workflow_a.json\n    \u251c\u2500\u2500 workflow_b.json\n    \u2514\u2500\u2500 ...\n</code></pre></li> <li>Determine the specific translation ruleset and repository via:<ol> <li>the Origins documentation</li> <li>the <code>orbiter list-rulesets</code> command</li> <li>or by creating a translation ruleset, if one does not exist</li> </ol> </li> <li>Install the translation ruleset via the <code>orbiter install</code> command</li> <li>Translate workloads via the <code>orbiter translate</code> command</li> <li>Review the contents of the output folder (default: <code>output/</code>).   If extensions or customizations are required, review how to extend a translation ruleset</li> <li>(optional) Initialize a full Airflow project    containing your migrated workloads with the <code>astro</code> CLI</li> <li>(optional) Deploy to Astro to run your translated workflows in production! \ud83d\ude80</li> </ol>"},{"location":"#authoring-rulesets-customization","title":"Authoring Rulesets &amp; Customization","text":"<p>Orbiter can be extended to fit specific needs, patterns, or to support additional origins.</p> <p>Read more specifics about how to use the framework at Rules and Objects</p>"},{"location":"#extend-or-customize","title":"Extend or Customize","text":"<p>To extend or customize an existing ruleset, you can easily modify it with simple Python code.</p> <ol> <li>Set up your workspace as described in steps 1+2 of the Translate instructions</li> <li>Create a Python script, named <code>override.py</code> <pre><code>.\n\u251c\u2500\u2500 override.py\n\u2514\u2500\u2500 workflow/\n    \u251c\u2500\u2500 workflow_a.json\n    \u251c\u2500\u2500 workflow_b.json\n    \u2514\u2500\u2500 ...\n</code></pre></li> <li> <p>Add contents to <code>override.py</code>:     override.py<pre><code>from orbiter_community_translations.dag_factory import translation_ruleset  # (1)!\nfrom orbiter.objects.operators.ssh import OrbiterSSHOperator  # (2)!\nfrom orbiter.rules import task_rule  # (3)!\n\n\n@task_rule(priority=99)  # (4)!\ndef ssh_rule(val: dict):\n    \"\"\"Demonstration of overriding rulesets, by switching DAG Factory BashOperators to SSHOperators\"\"\"\n    if val.pop(\"operator\", \"\") == \"BashOperator\":  # (5)!\n        return OrbiterSSHOperator(  # (6)!\n            command=val.pop(\"bash_command\"),\n            doc=\"Hello World!\",\n            **{k: v for k, v in val if k != \"dependencies\"},\n        )\n    else:\n        return None\n\n\ntranslation_ruleset.task_ruleset.ruleset.append(ssh_rule)  # (7)!\n</code></pre></p> <ol> <li>Importing specific translation ruleset, determined via the Origins page</li> <li>Importing required Objects</li> <li>Importing required Rule types</li> <li>Create one or more <code>@rule</code> functions, as required. A higher priority means this rule will be applied first.     <code>@task_rule</code> Reference</li> <li><code>Rules</code> have an <code>if/else</code> statement - they must always return a single thing or nothing</li> <li><code>OrbiterSSHOperator</code> Reference</li> <li>Append the new Rule    to the <code>translation_ruleset</code></li> </ol> </li> <li> <p>Invoke the <code>orbiter translate</code> command, pointing it at your customized ruleset     <pre><code>orbiter translate --ruleset override.translation_ruleset\n</code></pre></p> </li> <li>Follow the remaining steps of the Translate instructions</li> </ol>"},{"location":"#authoring-a-new-ruleset","title":"Authoring a new Ruleset","text":"<p>You can utilize the <code>TranslationRuleset</code> Template to create a new <code>TranslationRuleset</code>.</p>"},{"location":"#faq","title":"FAQ","text":"<ul> <li> <p>Can this tool convert my workflows from tool X to Airflow?</p> <p>If you don't see your tool listed in Supported Origins, contact us for services to create translations, create an issue in the <code>orbiter-community-translations</code> repository, or write a <code>TranslationRuleset</code> and submit a pull request to share your translations with the community.</p> </li> <li> <p>Are the results of this tool under any guarantee of correctness?</p> <p>No. This tool is provided as-is, with no guarantee of correctness. It is your responsibility to verify the results. We accept Pull Requests to improve parsing, and strive to make the tool easily configurable to handle your specific use-case.</p> </li> </ul> <p>Artwork Orbiter logo by Ivan Colic used with permission from The Noun Project under Creative Commons.</p>"},{"location":"cli/","title":"CLI","text":""},{"location":"cli/#orbiter","title":"orbiter","text":"<p>Orbiter is a CLI that converts other workflows to Airflow Projects.</p> <p>Usage:</p> <pre><code>orbiter [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--version</code> boolean Show the version and exit. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#analyze","title":"analyze","text":"<p>Analyze workflows in an <code>--input-dir</code> against a <code>--ruleset</code> and write analysis to an <code>--output-file</code>.</p> <p>Provide a specific ruleset with the <code>--ruleset</code> flag, or follow the prompt when given.</p> <p>Translations must already be installed with <code>orbiter install</code>.</p> <p>Run <code>orbiter list-rulesets</code> to see available rulesets.</p> <p>Usage:</p> <pre><code>orbiter analyze [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--input-dir</code> directory Directory containing workflows to translate. Will prompt, if not given. None <code>-r</code>, <code>--ruleset</code> text Qualified name of a TranslationRuleset. Will prompt, if not given. None <code>--format</code> choice (<code>json</code> | <code>csv</code> | <code>md</code>) [optional] format for analysis output <code>md</code> <code>-o</code>, <code>--output-file</code> filename File to write to, defaults to stdout <code>-</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#document","title":"document","text":"<p>Write Translation documentation as HTML.</p> <p>Translations must already be installed with <code>orbiter install</code>.</p> <p>Run <code>orbiter list-rulesets</code> to see available rulesets.</p> <p>Usage:</p> <pre><code>orbiter document [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-r</code>, <code>--ruleset</code> text Translation module to document (e.g <code>orbiter_translation.oozie.xml_demo</code>), can be supplied multiple times. Note: do not include <code>.translation_ruleset</code> at the end, to document the full module. Will prompt, if not given. None <code>--output-file</code>, <code>-o</code> filename HTML file to write to. Defaults to <code>translation_ruleset.html</code>. Use <code>-</code> to write to stdout <code>translation_ruleset.html</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#install","title":"install","text":"<p>Install a new Translation Ruleset from a repository.</p> <p>Run <code>orbiter list-rulesets</code> to see available rulesets.</p> <p>Usage:</p> <pre><code>orbiter install [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-r</code>, <code>--repo</code> choice (<code>astronomer-orbiter-translations</code> | <code>orbiter-community-translations</code>) Choose a repository to install. Will prompt, if not given. None <code>-k</code>, <code>--key</code> text [Optional] License Key to use for the translation ruleset. Should look like <code>AAAA-BBBB-1111-2222-3333-XXXX-YYYY-ZZZZ</code> None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#list-rulesets","title":"list-rulesets","text":"<p>List available Translation Rulesets.</p> <p>More info available in our docs: https://astronomer.github.io/orbiter/origins/#supported-origins.</p> <p>Usage:</p> <pre><code>orbiter list-rulesets [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#translate","title":"translate","text":"<p>Translate workflows in an <code>--input-dir</code> to an <code>--output-dir</code> Airflow Project.</p> <p>Translations must already be installed with <code>orbiter install</code></p> <p>Provide a specific ruleset with the <code>--ruleset</code> flag, or follow the prompt when given.</p> <p>Run <code>orbiter list-rulesets</code> to see available rulesets.</p> <p>Formats output with Ruff (https://astral.sh/ruff), by default.</p> <p>Usage:</p> <pre><code>orbiter translate [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--input-dir</code> directory Directory containing workflows to translate. Will prompt, if not given. None <code>--output-dir</code> directory Directory to write translated workflows to <code>/home/runner/work/orbiter/orbiter/output</code> <code>-r</code>, <code>--ruleset</code> text Qualified name of a TranslationRuleset. Will prompt, if not given. None <code>--format</code> / <code>--no-format</code> boolean [optional] format the output with Ruff <code>True</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#logging","title":"Logging","text":"<p>You can alter the verbosity of the CLI by setting the <code>LOG_LEVEL</code> environment variable. The default is <code>INFO</code>.</p> <pre><code>export LOG_LEVEL=DEBUG\n</code></pre>"},{"location":"cli/#autocomplete","title":"Autocomplete","text":"<p>Auto-completion is available for the CLI. To enable it, run the following command or place it in <code>.bashrc</code> or <code>.zshrc</code>:</p>"},{"location":"cli/#bash","title":"Bash","text":"<pre><code>eval \"$(_ORBITER_COMPLETE=bash_source orbiter)\"\n</code></pre>"},{"location":"cli/#zsh","title":"ZSH","text":"<pre><code>eval \"$(_ORBITER_COMPLETE=zsh_source orbiter)\"\n</code></pre>"},{"location":"origins/","title":"Origins","text":"<p>An Origin is a source system that contains workflows that can be translated to an Apache Airflow project.</p>"},{"location":"origins/#supported-origins","title":"Supported Origins","text":"Origin Maintainer Repository Ruleset DAG Equivalent Task Equivalent Argo Astronomer <code>orbiter-community-translations</code> WIP Workflow Step Automic Astronomer <code>orbiter-community-translations</code> <code>orbiter_translations.automic.xml_demo.translation_ruleset</code> Workflow Job Autosys Astronomer <code>orbiter-community-translations</code> <code>orbiter_translations.autosys.jil_demo.translation_ruleset</code> Job (or Box) Job\u2800 \u2800 \u2800 <code>astronomer-orbiter-translations</code> <code>orbiter_translations.autosys.jil_base.translation_ruleset</code> \u2800 \u2800 cron Community <code>orbiter-community-translations</code> WIP Job Command Control M Astronomer <code>orbiter-community-translations</code> <code>orbiter_translations.control_m.xml_demo.translation_ruleset</code> Folder Job \u2800 \u2800 <code>astronomer-orbiter-translations</code> <code>orbiter_translations.control_m.xml_base.translation_ruleset</code> \u2800 \u2800 \u2800 \u2800 \u2800 <code>orbiter_translations.control_m.json_base.translation_ruleset</code> \u2800 \u2800 \u2800 \u2800 \u2800 <code>orbiter_translations.control_m.json_ssh.translation_ruleset</code> \u2800 \u2800 DataStage Astronomer <code>orbiter-community-translations</code> <code>orbiter_translations.datastage.xml_demo.translation_ruleset</code> Job Stage DAG Factory Community <code>orbiter-community-translations</code> <code>orbiter_translations.dag_factory.yaml_base.translation_ruleset</code> DAG Task ESP Astronomer <code>orbiter-community-translations</code> <code>orbiter_translations.esp.txt_demo.translation_ruleset</code> Procedure (or Application) Job Github Actions Astronomer <code>orbiter-community-translations</code> WIP Workflow Task JAMS Astronomer <code>orbiter-community-translations</code> WIP Sequence Job Jenkins Astronomer <code>orbiter-community-translations</code> <code>orbiter_translations.jenkins.json_demo.translation_ruleset</code> Pipeline Stage Oozie Astronomer <code>orbiter-community-translations</code> <code>orbiter_translations.oozie.xml_demo.translation_ruleset</code> Workflow Node \u2800 Astronomer <code>astronomer-orbiter-translations</code> <code>orbiter_translations.oozie.xml_base.translation_ruleset</code> \u2800 \u2800 SSIS Astronomer <code>orbiter-community-translations</code> <code>orbiter_translations.ssis.xml_demo.translation_ruleset</code> Workflow Task Talend Astronomer <code>orbiter-community-translations</code> WIP Job Component &amp; more! \u2800 \u2800 \u2800 \u2800 \u2800 <p>For Astronomer maintained Translation Rulesets, please contact us for access to the most up-to-date versions.</p> <p>If you don't see your Origin system listed, please either:</p> <ul> <li>contact us for services to create translations</li> <li>create an issue in our <code>orbiter-community-translations</code> repository</li> <li>write a <code>TranslationRuleset</code> Template and submit a pull request to share your translations with the community</li> </ul>"},{"location":"Rules_and_Rulesets/","title":"Overview","text":"<p>The brain of the Orbiter framework is in it's <code>Rules</code> and the <code>Rulesets</code> that contain them.</p> <ul> <li>A <code>Rule</code> is a python function that is evaluated and produces something (typically an Object) or nothing</li> <li>A <code>Ruleset</code> is a collection of <code>Rules</code> that are     evaluated in priority order</li> <li>A <code>TranslationRuleset</code>     is a collection of <code>Rulesets</code>,     relating to an Origin and <code>FileType</code>,     with a <code>translate_fn</code> which determines how to apply the rulesets.</li> </ul> <p>Different <code>Rules</code> are applied in different scenarios, such as:</p> <ul> <li>converting input to an Airflow DAG (<code>@dag_rule</code>),</li> <li>converting input to a specific Airflow Operator (<code>@task_rule</code>),</li> <li>filtering entries from the input data (<code>@dag_filter_rule</code>, <code>@task_filter_rule</code>).</li> </ul> <p>Tip</p> <p>To map the following input <pre><code>{\n    \"id\": \"my_task\",\n    \"command\": \"echo 'hi'\"\n}\n</code></pre></p> <p>to an Airflow BashOperator, a <code>Rule</code> could parse it as follows:</p> <pre><code>@task_rule\ndef my_rule(val):\n    if 'command' in val:\n        return OrbiterBashOperator(task_id=val['id'], bash_command=val['command'])\n    else:\n        return None\n</code></pre> <p>This returns a <code>OrbiterBashOperator</code>, which will become an Airflow BashOperator when the translation completes.</p>"},{"location":"Rules_and_Rulesets/#orbiter.rules.rulesets.translate","title":"orbiter.rules.rulesets.translate","text":"<pre><code>translate(\n    translation_ruleset, input_dir: Path\n) -&gt; OrbiterProject\n</code></pre> <p>Orbiter expects a folder containing text files which may have a structure like: <pre><code>{\"&lt;workflow name&gt;\": { ...&lt;workflow properties&gt;, \"&lt;task name&gt;\": { ...&lt;task properties&gt;} }}\n</code></pre></p> <p>The standard translation function performs the following steps:</p> <p></p> <ol> <li>Find all files with the expected     <code>TranslationRuleset.file_type</code>     (<code>.json</code>, <code>.xml</code>, <code>.yaml</code>, etc.) in the input folder.<ul> <li>Load each file and turn it into a Python Dictionary.</li> </ul> </li> <li>For each file: Apply the <code>TranslationRuleset.dag_filter_ruleset</code>     to filter down to entries that can translate to a DAG, in priority order.     The file name is added under a <code>__file</code> key to both input and output dictionaries for the DAG Filter rule.<ul> <li>For each dictionary: Apply the <code>TranslationRuleset.dag_ruleset</code>, to convert the object to an <code>OrbiterDAG</code>, in priority-order, stopping when the first rule returns a match. If no rule returns a match, the entry is filtered.</li> </ul> </li> <li>Apply the <code>TranslationRuleset.task_filter_ruleset</code>     to filter down to entries in the DAG that can translate to a Task, in priority-order.<ul> <li>For each: Apply the <code>TranslationRuleset.task_ruleset</code>,     to convert the object to a specific Task, in priority-order, stopping when the first rule returns a match.     If no rule returns a match, the entry is filtered.</li> </ul> </li> <li>After the DAG and Tasks are mapped, the     <code>TranslationRuleset.task_dependency_ruleset</code>     is applied in priority-order, stopping when the first rule returns a match,     to create a list of     <code>OrbiterTaskDependency</code>,     which are then added to each task in the     <code>OrbiterDAG</code></li> <li>Apply the <code>TranslationRuleset.post_processing_ruleset</code>,     against the <code>OrbiterProject</code>, which can make modifications after all     other rules have been applied.</li> <li>After translation - the <code>OrbiterProject</code>     is rendered to the output folder.</li> </ol> Source code in <code>orbiter/rules/rulesets.py</code> <pre><code>@validate_call\ndef translate(translation_ruleset, input_dir: Path) -&gt; OrbiterProject:\n    \"\"\"\n    Orbiter expects a folder containing text files which may have a structure like:\n    ```json\n    {\"&lt;workflow name&gt;\": { ...&lt;workflow properties&gt;, \"&lt;task name&gt;\": { ...&lt;task properties&gt;} }}\n    ```\n\n    The standard translation function performs the following steps:\n\n    ![Diagram of Orbiter Translation](../orbiter_diagram.png)\n\n    1. [**Find all files**][orbiter.rules.rulesets.TranslationRuleset.get_files_with_extension] with the expected\n        [`TranslationRuleset.file_type`][orbiter.rules.rulesets.TranslationRuleset]\n        (`.json`, `.xml`, `.yaml`, etc.) in the input folder.\n        - [**Load each file**][orbiter.rules.rulesets.TranslationRuleset.loads] and turn it into a Python Dictionary.\n    2. **For each file:** Apply the [`TranslationRuleset.dag_filter_ruleset`][orbiter.rules.rulesets.DAGFilterRuleset]\n        to filter down to entries that can translate to a DAG, in priority order.\n        The file name is added under a `__file` key to both input and output dictionaries for the DAG Filter rule.\n        - **For each dictionary**: Apply the [`TranslationRuleset.dag_ruleset`][orbiter.rules.rulesets.DAGRuleset],\n        to convert the object to an [`OrbiterDAG`][orbiter.objects.dag.OrbiterDAG],\n        in priority-order, stopping when the first rule returns a match.\n        If no rule returns a match, the entry is filtered.\n    3. Apply the [`TranslationRuleset.task_filter_ruleset`][orbiter.rules.rulesets.TaskFilterRuleset]\n        to filter down to entries in the DAG that can translate to a Task, in priority-order.\n        - **For each:** Apply the [`TranslationRuleset.task_ruleset`][orbiter.rules.rulesets.TaskRuleset],\n            to convert the object to a specific Task, in priority-order, stopping when the first rule returns a match.\n            If no rule returns a match, the entry is filtered.\n    4. After the DAG and Tasks are mapped, the\n        [`TranslationRuleset.task_dependency_ruleset`][orbiter.rules.rulesets.TaskDependencyRuleset]\n        is applied in priority-order, stopping when the first rule returns a match,\n        to create a list of\n        [`OrbiterTaskDependency`][orbiter.objects.task.OrbiterTaskDependency],\n        which are then added to each task in the\n        [`OrbiterDAG`][orbiter.objects.dag.OrbiterDAG]\n    5. Apply the [`TranslationRuleset.post_processing_ruleset`][orbiter.rules.rulesets.PostProcessingRuleset],\n        against the [`OrbiterProject`][orbiter.objects.project.OrbiterProject], which can make modifications after all\n        other rules have been applied.\n    6. After translation - the [`OrbiterProject`][orbiter.objects.project.OrbiterProject]\n        is rendered to the output folder.\n    \"\"\"\n    if not isinstance(translation_ruleset, TranslationRuleset):\n        raise RuntimeError(\n            f\"Error! type(translation_ruleset)=={type(translation_ruleset)}!=TranslationRuleset! Exiting!\"\n        )\n\n    # Create an initial OrbiterProject\n    project = OrbiterProject()\n\n    for i, (file, input_dict) in enumerate(translation_ruleset.get_files_with_extension(input_dir)):\n        logger.info(f\"Translating [File {i}]={file.resolve()}\")\n\n        # DAG FILTER Ruleset - filter down to keys suspected of being translatable to a DAG, in priority order.\n        # Add __file DAG FILTER inputs and outputs, so it's available for both DAG and DAG FILTER rules\n        __file_addition = {\"__file\": (input_dir / file.relative_to(input_dir))}\n        dag_dicts: List[dict] = [\n            __file_addition | dag_dict\n            for dag_dict in functools.reduce(\n                add,\n                translation_ruleset.dag_filter_ruleset.apply(val=input_dict | __file_addition),\n                [],\n            )\n        ]\n        logger.debug(f\"Found {len(dag_dicts)} DAG candidates in {file.resolve()}\")\n        for dag_dict in dag_dicts:\n            # DAG Ruleset - convert the object to an `OrbiterDAG` via `dag_ruleset`,\n            #         in priority-order, stopping when the first rule returns a match\n            dag: OrbiterDAG | None = translation_ruleset.dag_ruleset.apply(\n                val=dag_dict,\n                take_first=True,\n            )\n            if dag is None:\n                logger.warning(\n                    f\"Couldn't extract DAG from dag_dict={dag_dict} with dag_ruleset={translation_ruleset.dag_ruleset}\"\n                )\n                continue\n            dag.orbiter_kwargs[\"file_path\"] = file.relative_to(input_dir)\n\n            tasks = {}\n            # TASK FILTER Ruleset - Many entries in dag_dict -&gt; Many task_dict\n            task_dicts = functools.reduce(\n                add,\n                translation_ruleset.task_filter_ruleset.apply(val=dag_dict),\n                [],\n            )\n            logger.debug(f\"Found {len(task_dicts)} Task candidates in {dag.dag_id} in {file.resolve()}\")\n            for task_dict in task_dicts:\n                # TASK Ruleset one -&gt; one\n                task: OrbiterOperator = translation_ruleset.task_ruleset.apply(val=task_dict, take_first=True)\n                if task is None:\n                    logger.warning(f\"Couldn't extract task from expected task_dict={task_dict}\")\n                    continue\n\n                _add_task_deduped(task, tasks)\n            logger.debug(f\"Adding {len(tasks)} tasks to DAG {dag.dag_id}\")\n            dag.add_tasks(tasks.values())\n\n            # Dag-Level TASK DEPENDENCY Ruleset\n            task_dependencies: List[OrbiterTaskDependency] = (\n                list(chain(*translation_ruleset.task_dependency_ruleset.apply(val=dag))) or []\n            )\n            if not len(task_dependencies):\n                logger.warning(f\"Couldn't find task dependencies in dag={trim_dict(dag_dict)}\")\n            for task_dependency in task_dependencies:\n                task_dependency: OrbiterTaskDependency\n                if parent := _get_parent_for_task_dependency(task_dependency, dag):\n                    parent.tasks[task_dependency.task_id].add_downstream(task_dependency)\n                else:\n                    logger.warning(f\"Couldn't find task_id={task_dependency.task_id} in tasks for dag_id={dag.dag_id}\")\n                    continue\n\n            logger.debug(f\"Adding DAG {dag.dag_id} to project\")\n            project.add_dags(dag)\n\n    # POST PROCESSING Ruleset\n    translation_ruleset.post_processing_ruleset.apply(val=project, take_first=False)\n\n    return project\n</code></pre>"},{"location":"Rules_and_Rulesets/rules/","title":"Rules","text":""},{"location":"Rules_and_Rulesets/rules/#orbiter.rules.Rule","title":"orbiter.rules.Rule","text":"<p>A <code>Rule</code> contains a python function that is evaluated and produces something (typically an Object) or nothing</p> <p>A <code>Rule</code> can be created from a decorator <pre><code>&gt;&gt;&gt; @rule(priority=1)\n... def my_rule(val):\n...     return 1\n&gt;&gt;&gt; isinstance(my_rule, Rule)\nTrue\n&gt;&gt;&gt; my_rule(val={})\n1\n</code></pre></p> <p>The function in a rule takes one parameter (<code>val</code>), and must always evaluate to something or nothing. <pre><code>&gt;&gt;&gt; Rule(rule=lambda val: 4)({})\n4\n&gt;&gt;&gt; Rule(rule=lambda val: None)({})\n</code></pre></p> <p>Tip</p> <p>If the returned value is an Orbiter Object, the passed <code>kwargs</code> are saved in a special <code>orbiter_kwargs</code> property</p> <pre><code>&gt;&gt;&gt; from orbiter.objects.dag import OrbiterDAG\n&gt;&gt;&gt; @rule\n... def my_rule(foo):\n...     return OrbiterDAG(dag_id=\"\", file_path=\"\")\n&gt;&gt;&gt; my_rule(foo=\"bar\").orbiter_kwargs\n{'foo': 'bar'}\n</code></pre> <p>Note</p> <p>A <code>Rule</code> must have a <code>rule</code> property and extra properties cannot be passed</p> <pre><code>&gt;&gt;&gt; # noinspection Pydantic\n... Rule(rule=lambda: None, not_a_prop=\"???\")\n... # doctest: +ELLIPSIS\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n</code></pre> <p>Parameters:</p> Name Type Description <code>rule</code> <code>Callable[[dict | Any], Any | None]</code> <p>Python function to evaluate. Takes a single argument and returns something or nothing</p> <code>priority</code> <code>int, optional</code> <p>Higher priority rules are evaluated first, must be greater than 0. Default is 0</p>"},{"location":"Rules_and_Rulesets/rules/#orbiter.rules.DAGFilterRule","title":"orbiter.rules.DAGFilterRule","text":"<p>               Bases: <code>Rule</code></p> <p>The <code>@dag_filter_rule</code> decorator creates a <code>DAGFilterRule</code></p> <pre><code>@dag_filter_rule\ndef foo(val: dict) -&gt; List[dict]:\n    return [{\"dag_id\": \"foo\"}]\n</code></pre> <p>Hint</p> <p>In addition to filtering, a <code>DAGFilterRule</code> can also map input to a more reasonable output for later processing</p>"},{"location":"Rules_and_Rulesets/rules/#orbiter.rules.DAGRule","title":"orbiter.rules.DAGRule","text":"<p>               Bases: <code>Rule</code></p> <p>A <code>@dag_rule</code> decorator creates a <code>DAGRule</code></p> <p>Tip</p> <p>A <code>__file</code> key is added to the original input, which is the file path of the input.</p> <pre><code>@dag_rule\ndef foo(val: dict) -&gt; OrbiterDAG | None:\n    if \"id\" in val:\n        return OrbiterDAG(dag_id=val[\"id\"], file_path=f\"{val[\"id\"]}.py\")\n    else:\n        return None\n</code></pre>"},{"location":"Rules_and_Rulesets/rules/#orbiter.rules.TaskFilterRule","title":"orbiter.rules.TaskFilterRule","text":"<p>               Bases: <code>Rule</code></p> <p>A <code>@task_filter_rule</code> decorator creates a <code>TaskFilterRule</code></p> <pre><code>@task_filter_rule\ndef foo(val: dict) -&gt; List[dict] | None:\n    return [{\"task_id\": \"foo\"}]\n</code></pre> <p>Hint</p> <p>In addition to filtering, a <code>TaskFilterRule</code> can also map input to a more reasonable output for later processing</p> <p>Parameters:</p> Name Type Description <code>val</code> <code>dict</code> <p>A dictionary of the task</p> <p>Returns:</p> Type Description <code>List[dict] | None</code> <p>A list of dictionaries of possible tasks or <code>None</code></p>"},{"location":"Rules_and_Rulesets/rules/#orbiter.rules.TaskRule","title":"orbiter.rules.TaskRule","text":"<p>               Bases: <code>Rule</code></p> <p>A <code>@task_rule</code> decorator creates a <code>TaskRule</code></p> <pre><code>@task_rule\ndef foo(val: dict) -&gt; OrbiterOperator | OrbiterTaskGroup:\n    if \"id\" in val and \"command\" in val:\n        return OrbiterBashOperator(\n            task_id=val[\"id\"], bash_command=val[\"command\"]\n        )\n    else:\n        return None\n</code></pre> <p>Parameters:</p> Name Type Description <code>val</code> <code>dict</code> <p>A dictionary of the task</p> <p>Returns:</p> Type Description <code>OrbiterOperator | OrbiterTaskGroup | None</code> <p>A subclass of <code>OrbiterOperator</code> or <code>OrbiterTaskGroup</code> or <code>None</code></p>"},{"location":"Rules_and_Rulesets/rules/#orbiter.rules.TaskDependencyRule","title":"orbiter.rules.TaskDependencyRule","text":"<p>               Bases: <code>Rule</code></p> <p>An <code>@task_dependency_rule</code> decorator creates a <code>TaskDependencyRule</code>, which takes an <code>OrbiterDAG</code> and returns a <code>list[OrbiterTaskDependency]</code> or <code>None</code></p> <pre><code>@task_dependency_rule\ndef foo(val: OrbiterDAG) -&gt; OrbiterTaskDependency:\n    return [OrbiterTaskDependency(task_id=\"upstream\", downstream=\"downstream\")]\n</code></pre> <p>Parameters:</p> Name Type Description <code>val</code> <code>OrbiterDAG</code> <p>An <code>OrbiterDAG</code></p> <p>Returns:</p> Type Description <code>List[OrbiterTaskDependency] | None</code> <p>A list of <code>OrbiterTaskDependency</code> or <code>None</code></p>"},{"location":"Rules_and_Rulesets/rules/#orbiter.rules.PostProcessingRule","title":"orbiter.rules.PostProcessingRule","text":"<p>               Bases: <code>Rule</code></p> <p>An <code>@post_processing_rule</code> decorator creates a <code>PostProcessingRule</code>, which takes an <code>OrbiterProject</code>, after all other rules have been applied, and modifies it in-place.</p> <pre><code>@post_processing_rule\ndef foo(val: OrbiterProject) -&gt; None:\n    val.dags[\"foo\"].tasks[\"bar\"].doc = \"Hello World\"\n</code></pre> <p>Parameters:</p> Name Type Description <code>val</code> <code>OrbiterProject</code> <p>An <code>OrbiterProject</code></p> <p>Returns:</p> Type Description <code>None</code> <p><code>None</code></p>"},{"location":"Rules_and_Rulesets/rulesets/","title":"Translation","text":""},{"location":"Rules_and_Rulesets/rulesets/#orbiter.rules.rulesets.TranslationRuleset","title":"orbiter.rules.rulesets.TranslationRuleset","text":"<p>A <code>Ruleset</code> is a collection of <code>Rules</code> that are evaluated in priority order</p> <p>A <code>TranslationRuleset</code> is a container for <code>Rulesets</code>, which applies to a specific translation</p> <pre><code>&gt;&gt;&gt; TranslationRuleset(\n...   file_type={FileTypeJSON},                                      # Has a file type\n...   translate_fn=fake_translate,                                  # and can have a callable\n...   # translate_fn=\"orbiter.rules.translate.fake_translate\",      # or a qualified name to a function\n...   dag_filter_ruleset={\"ruleset\": [{\"rule\": lambda x: None}]},   # Rulesets can be dict within dicts\n...   dag_ruleset=DAGRuleset(ruleset=[Rule(rule=lambda x: None)]),  # or objects within objects\n...   task_filter_ruleset=EMPTY_RULESET,                            # or a mix\n...   task_ruleset=EMPTY_RULESET,\n...   task_dependency_ruleset=EMPTY_RULESET,                        # Omitted for brevity\n...   post_processing_ruleset=EMPTY_RULESET,\n... )\nTranslationRuleset(...)\n</code></pre> <p>Parameters:</p> Name Type Description <code>file_type</code> <code>Set[Type[FileType]]</code> <p>FileType to translate</p> <code>dag_filter_ruleset</code> <code>DAGFilterRuleset | dict</code> <p><code>DAGFilterRuleset</code> (of <code>DAGFilterRule</code>)</p> <code>dag_ruleset</code> <code>DAGRuleset | dict</code> <p><code>DAGRuleset</code> (of <code>DAGRules</code>)</p> <code>task_filter_ruleset</code> <code>TaskFilterRuleset | dict</code> <p><code>TaskFilterRuleset</code> (of <code>TaskFilterRule</code>)</p> <code>task_ruleset</code> <code>TaskRuleset | dict</code> <p><code>TaskRuleset</code> (of <code>TaskRules</code>)</p> <code>task_dependency_ruleset</code> <code>TaskDependencyRuleset | dict</code> <p><code>TaskDependencyRuleset</code> (of <code>TaskDependencyRules</code>)</p> <code>post_processing_ruleset</code> <code>PostProcessingRuleset | dict</code> <p><code>PostProcessingRuleset</code> (of <code>PostProcessingRules</code>)</p> <code>translate_fn</code> <code>Callable[[TranslationRuleset, Path], OrbiterProject] | str | TranslateFn</code> <p>Either a qualified name to a function (e.g. <code>path.to.file.function</code>), or a function reference, with the signature:  <code>(</code><code>translation_ruleset: Translation Ruleset</code><code>, input_dir: Path) -&gt;</code> <code>OrbiterProject</code></p> <p>Methods:</p> Name Description <code>dumps</code> <p>Convert Python dictionary back to source string form, useful for testing</p> <code>get_ext</code> <p>Get the first file extension for this ruleset</p> <code>get_files_with_extension</code> <p>A generator that yields files with a specific extension(s) in a directory</p> <code>loads</code> <p>Converts all files of type into a Python dictionary \"intermediate representation\" form,</p> <code>test</code> <p>Test an input against the whole ruleset.</p>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.rules.rulesets.TranslationRuleset.dumps","title":"dumps","text":"<pre><code>dumps(input_dict: dict, ext: str | None = None) -&gt; str\n</code></pre> <p>Convert Python dictionary back to source string form, useful for testing</p> <p>Parameters:</p> Name Type Description <code>input_dict</code> <code>dict</code> <p>The dictionary to convert to a string</p> <code>ext</code> <code>str | None</code> <p>The file type extension to dump as, defaults to first 'file_type' in the set</p> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the input_dict, in the file_type format</p> Source code in <code>orbiter/rules/rulesets.py</code> <pre><code>@validate_call\ndef dumps(self, input_dict: dict, ext: str | None = None) -&gt; str:\n    \"\"\"\n    Convert Python dictionary back to source string form, useful for testing\n\n    :param input_dict: The dictionary to convert to a string\n    :type input_dict: dict\n    :param ext: The file type extension to dump as, defaults to first 'file_type' in the set\n    :type ext: str | None\n    :return str: The string representation of the input_dict, in the file_type format\n    :rtype: str\n    \"\"\"\n    for file_type in self.file_type:\n        if ext is None or ext.lower() in file_type.extension:\n            return file_type.dump_fn(input_dict)\n    raise TypeError(f\"Invalid file_type={ext}\")\n</code></pre>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.rules.rulesets.TranslationRuleset.get_ext","title":"get_ext","text":"<pre><code>get_ext() -&gt; str\n</code></pre> <p>Get the first file extension for this ruleset</p> <pre><code>&gt;&gt;&gt; EMPTY_TRANSLATION_RULESET.get_ext()\n'JSON'\n</code></pre> Source code in <code>orbiter/rules/rulesets.py</code> <pre><code>def get_ext(self) -&gt; str:\n    \"\"\"\n    Get the first file extension for this ruleset\n\n    ```pycon\n    &gt;&gt;&gt; EMPTY_TRANSLATION_RULESET.get_ext()\n    'JSON'\n\n    ```\n    \"\"\"\n    return next(iter(next(iter(self.file_type)).extension))\n</code></pre>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.rules.rulesets.TranslationRuleset.get_files_with_extension","title":"get_files_with_extension","text":"<pre><code>get_files_with_extension(\n    input_dir: Path,\n) -&gt; Generator[Path, dict]\n</code></pre> <p>A generator that yields files with a specific extension(s) in a directory</p> <p>Parameters:</p> Name Type Description <code>input_dir</code> <code>Path</code> <p>The directory to search in</p> <p>Returns:</p> Type Description <code>Generator[Path, dict]</code> <p>Generator item of (Path, dict) for each file found</p> Source code in <code>orbiter/rules/rulesets.py</code> <pre><code>def get_files_with_extension(self, input_dir: Path) -&gt; Generator[Path, dict]:\n    \"\"\"\n    A generator that yields files with a specific extension(s) in a directory\n\n    :param input_dir: The directory to search in\n    :type input_dir: Path\n    :return: Generator item of (Path, dict) for each file found\n    :rtype: Generator[Path, dict]\n    \"\"\"\n    for directory, _, files in input_dir.walk() if hasattr(input_dir, \"walk\") else _backport_walk(input_dir):\n        logger.debug(f\"Checking directory={directory}\")\n        for file in files:\n            file = directory / file\n            # noinspection PyBroadException\n            try:\n                yield (\n                    # Return the file path\n                    file,\n                    # and load the file and convert it into a python dict\n                    self.loads(file),\n                )\n            except TypeError:\n                logger.debug(f\"File={file} not of correct type, skipping...\")\n                continue\n</code></pre>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.rules.rulesets.TranslationRuleset.loads","title":"loads","text":"<pre><code>loads(file: Path) -&gt; dict\n</code></pre> <p>Converts all files of type into a Python dictionary \"intermediate representation\" form, prior to any rulesets being applied.</p> <p>Parameters:</p> Name Type Description <code>file</code> <code>Path</code> <p>The file to load</p> <p>Returns:</p> Type Description <code>dict</code> <p>The dictionary representation of the input_str</p> Source code in <code>orbiter/rules/rulesets.py</code> <pre><code>@validate_call\ndef loads(self, file: Path) -&gt; dict:\n    \"\"\"\n    Converts all files of type into a Python dictionary \"intermediate representation\" form,\n    prior to any rulesets being applied.\n\n    :param file: The file to load\n    :type file: Path\n    :return: The dictionary representation of the input_str\n    :rtype: dict\n    \"\"\"\n    for file_type in self.file_type:\n        if file.suffix.lower() in {f\".{ext.lower()}\" for ext in file_type.extension}:\n            try:\n                return file_type.load_fn(file.read_text())\n            except Exception as e:\n                logger.error(f\"Error loading file={file}! Skipping!\\n{e}\")\n                continue\n    raise TypeError(f\"Invalid file_type={file.suffix}, does not match file_type={self.file_type}\")\n</code></pre>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.rules.rulesets.TranslationRuleset.test","title":"test","text":"<pre><code>test(input_value: str | dict) -&gt; OrbiterProject\n</code></pre> <p>Test an input against the whole ruleset. - 'input_dict' (a parsed python dict) - or 'input_str' (raw value) to test against the ruleset.</p> <p>Parameters:</p> Name Type Description <code>input_value</code> <code>str | dict</code> <p>The input to test can be either a dict (passed to <code>translate_ruleset.dumps()</code> before <code>translate_ruleset.loads()</code>) or a string (read directly by <code>translate_ruleset.loads()</code>)</p> <p>Returns:</p> Type Description <code>OrbiterProject</code> <p>OrbiterProject produced after applying the ruleset</p> Source code in <code>orbiter/rules/rulesets.py</code> <pre><code>def test(self, input_value: str | dict) -&gt; OrbiterProject:\n    \"\"\"\n    Test an input against the whole ruleset.\n    - 'input_dict' (a parsed python dict)\n    - or 'input_str' (raw value) to test against the ruleset.\n\n    :param input_value: The input to test\n        can be either a dict (passed to `translate_ruleset.dumps()` before `translate_ruleset.loads()`)\n        or a string (read directly by `translate_ruleset.loads()`)\n    :type input_value: str | dict\n    :return: OrbiterProject produced after applying the ruleset\n    :rtype: OrbiterProject\n    \"\"\"\n    with TemporaryDirectory() as tempdir:\n        file = Path(tempdir) / f\"{uuid.uuid4()}.{self.get_ext()}\"\n        file.write_text(self.dumps(input_value) if isinstance(input_value, dict) else input_value)\n        return self.translate_fn(translation_ruleset=self, input_dir=file.parent)\n</code></pre>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.file_types","title":"orbiter.file_types","text":"<p>Classes:</p> Name Description <code>FileType</code> <p>Abstract Base File Type</p> <code>FileTypeJIL</code> <p>JIL File Type</p> <code>FileTypeJSON</code> <p>JSON File Type</p> <code>FileTypeXML</code> <p>XML File Type</p> <code>FileTypeYAML</code> <p>YAML File Type</p> <p>Functions:</p> Name Description <code>xmltodict_parse</code> <p>Calls <code>xmltodict.parse</code> and does post-processing fixes.</p>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.file_types.FileType","title":"FileType","text":"<p>Abstract Base File Type</p> <p>Parameters:</p> Name Type Description <code>extension</code> <code>Set[str]</code> <p>The file extension(s) for this file type</p> <code>load_fn</code> <code>Callable[[str], dict]</code> <p>The function to load the file into a dictionary for this file type</p> <code>dump_fn</code> <code>Callable[[dict], str]</code> <p>The function to dump a dictionary to a string for this file type</p>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.file_types.FileTypeJIL","title":"FileTypeJIL","text":"<p>JIL File Type</p> <p>Parameters:</p> Name Type Description <code>extension</code> <code>Set[str]</code> <p>JIL</p> <code>load_fn</code> <code>Callable[[str], dict]</code> <p>custom JIL loading function</p> <code>dump_fn</code> <code>Callable[[dict], str]</code> <p>custom JIL dumping function</p>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.file_types.FileTypeJSON","title":"FileTypeJSON","text":"<p>JSON File Type</p> <pre><code>&gt;&gt;&gt; out = FileTypeJSON.dump_fn({'a': 1}); out\n'{\"a\": 1}'\n&gt;&gt;&gt; FileTypeJSON.load_fn(out)\n{'a': 1}\n</code></pre> <p>Parameters:</p> Name Type Description <code>extension</code> <code>Set[str]</code> <p>JSON</p> <code>load_fn</code> <code>Callable[[str], dict]</code> <p>json.loads</p> <code>dump_fn</code> <code>Callable[[dict], str]</code> <p>json.dumps</p>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.file_types.FileTypeXML","title":"FileTypeXML","text":"<p>XML File Type</p> <p>Note</p> <p>This class uses a custom <code>xmltodict_parse</code> method to standardize the output to a list of dictionaries</p> <pre><code>&gt;&gt;&gt; out = FileTypeXML.dump_fn({'a': 1}); out\n'&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n&lt;a&gt;1&lt;/a&gt;'\n&gt;&gt;&gt; FileTypeXML.load_fn(out)\n{'a': '1'}\n</code></pre> <p>Parameters:</p> Name Type Description <code>extension</code> <code>Set[str]</code> <p>XML</p> <code>load_fn</code> <code>Callable[[str], dict]</code> <p>xmltodict_parse</p> <code>dump_fn</code> <code>Callable[[dict], str]</code> <p>xmltodict.unparse</p>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.file_types.FileTypeYAML","title":"FileTypeYAML","text":"<p>YAML File Type</p> <pre><code>&gt;&gt;&gt; out = FileTypeYAML.dump_fn({'a': 1}); out\n'a: 1\\n'\n&gt;&gt;&gt; FileTypeYAML.load_fn(out)\n{'a': 1}\n</code></pre> <p>Parameters:</p> Name Type Description <code>extension</code> <code>Set[str]</code> <p>YAML, YML</p> <code>load_fn</code> <code>Callable[[str], dict]</code> <p>yaml.safe_load</p> <code>dump_fn</code> <code>Callable[[dict], str]</code> <p>yaml.safe_dump</p>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.file_types.xmltodict_parse","title":"xmltodict_parse","text":"<pre><code>xmltodict_parse(input_str: str) -&gt; Any\n</code></pre> <p>Calls <code>xmltodict.parse</code> and does post-processing fixes.</p> <p>Note</p> <p>The original <code>xmltodict.parse</code> method returns EITHER:</p> <ul> <li>a dict (one child element of type)</li> <li>or a list of dict (many child element of type)</li> </ul> <p>This behavior can be confusing, and is an issue with the original xml spec being referenced.</p> <p>This method deviates by standardizing to the latter case (always a <code>list[dict]</code>).</p> <p>All XML elements will be a list of dictionaries, even if there's only one element.</p> <pre><code>&gt;&gt;&gt; xmltodict_parse(\"\")\nTraceback (most recent call last):\nxml.parsers.expat.ExpatError: no element found: line 1, column 0\n&gt;&gt;&gt; xmltodict_parse(\"&lt;a&gt;&lt;/a&gt;\")\n{'a': None}\n&gt;&gt;&gt; xmltodict_parse(\"&lt;a foo='bar'&gt;&lt;/a&gt;\")\n{'a': [{'@foo': 'bar'}]}\n&gt;&gt;&gt; xmltodict_parse(\"&lt;a foo='bar'&gt;&lt;foo bar='baz'&gt;&lt;/foo&gt;&lt;/a&gt;\")  # Singleton - gets modified\n{'a': [{'@foo': 'bar', 'foo': [{'@bar': 'baz'}]}]}\n&gt;&gt;&gt; xmltodict_parse(\"&lt;a foo='bar'&gt;&lt;foo bar='baz'&gt;&lt;bar&gt;&lt;bop&gt;&lt;/bop&gt;&lt;/bar&gt;&lt;/foo&gt;&lt;/a&gt;\")  # Nested Singletons - modified\n{'a': [{'@foo': 'bar', 'foo': [{'@bar': 'baz', 'bar': [{'bop': None}]}]}]}\n&gt;&gt;&gt; xmltodict_parse(\"&lt;a foo='bar'&gt;&lt;foo bar='baz'&gt;&lt;/foo&gt;&lt;foo bing='bop'&gt;&lt;/foo&gt;&lt;/a&gt;\")\n{'a': [{'@foo': 'bar', 'foo': [{'@bar': 'baz'}, {'@bing': 'bop'}]}]}\n&gt;&gt;&gt; xmltodict_parse(\"&lt;a&gt;&amp;lt;?xml version=&amp;apos;1.0&amp;apos; encoding=&amp;apos;UTF-16&amp;apos;?&amp;gt;&amp;lt;Properties version=&amp;apos;1.1&amp;apos;&amp;gt;&amp;lt;/Properties&amp;gt;&lt;/a&gt;\")\n{'a': {'Properties': [{'@version': '1.1'}]}}\n</code></pre> <p>Parameters:</p> Name Type Description <code>input_str</code> <code>str</code> <p>The XML string to parse</p> <p>Returns:</p> Type Description <code>dict</code> <p>The parsed XML</p> Source code in <code>orbiter/file_types.py</code> <pre><code>def xmltodict_parse(input_str: str) -&gt; Any:\n    \"\"\"Calls `xmltodict.parse` and does post-processing fixes.\n\n    !!! note\n\n        The original [`xmltodict.parse`](https://pypi.org/project/xmltodict/) method returns EITHER:\n\n        - a dict (one child element of type)\n        - or a list of dict (many child element of type)\n\n        This behavior can be confusing, and is an issue with the original xml spec being referenced.\n\n        **This method deviates by standardizing to the latter case (always a `list[dict]`).**\n\n        **All XML elements will be a list of dictionaries, even if there's only one element.**\n\n    ```pycon\n    &gt;&gt;&gt; xmltodict_parse(\"\")\n    Traceback (most recent call last):\n    xml.parsers.expat.ExpatError: no element found: line 1, column 0\n    &gt;&gt;&gt; xmltodict_parse(\"&lt;a&gt;&lt;/a&gt;\")\n    {'a': None}\n    &gt;&gt;&gt; xmltodict_parse(\"&lt;a foo='bar'&gt;&lt;/a&gt;\")\n    {'a': [{'@foo': 'bar'}]}\n    &gt;&gt;&gt; xmltodict_parse(\"&lt;a foo='bar'&gt;&lt;foo bar='baz'&gt;&lt;/foo&gt;&lt;/a&gt;\")  # Singleton - gets modified\n    {'a': [{'@foo': 'bar', 'foo': [{'@bar': 'baz'}]}]}\n    &gt;&gt;&gt; xmltodict_parse(\"&lt;a foo='bar'&gt;&lt;foo bar='baz'&gt;&lt;bar&gt;&lt;bop&gt;&lt;/bop&gt;&lt;/bar&gt;&lt;/foo&gt;&lt;/a&gt;\")  # Nested Singletons - modified\n    {'a': [{'@foo': 'bar', 'foo': [{'@bar': 'baz', 'bar': [{'bop': None}]}]}]}\n    &gt;&gt;&gt; xmltodict_parse(\"&lt;a foo='bar'&gt;&lt;foo bar='baz'&gt;&lt;/foo&gt;&lt;foo bing='bop'&gt;&lt;/foo&gt;&lt;/a&gt;\")\n    {'a': [{'@foo': 'bar', 'foo': [{'@bar': 'baz'}, {'@bing': 'bop'}]}]}\n    &gt;&gt;&gt; xmltodict_parse(\"&lt;a&gt;&amp;lt;?xml version=&amp;apos;1.0&amp;apos; encoding=&amp;apos;UTF-16&amp;apos;?&amp;gt;&amp;lt;Properties version=&amp;apos;1.1&amp;apos;&amp;gt;&amp;lt;/Properties&amp;gt;&lt;/a&gt;\")\n    {'a': {'Properties': [{'@version': '1.1'}]}}\n\n    ```\n    :param input_str: The XML string to parse\n    :type input_str: str\n    :return: The parsed XML\n    :rtype: dict\n    \"\"\"\n\n    def _fix_escaped_xml(v):\n        try:\n            parsed_unescaped_xml = xmltodict.parse(v)\n            _fix(parsed_unescaped_xml)\n            return parsed_unescaped_xml\n        except Exception as e:\n            logger.debug(f\"Error parsing escaped XML: {e}\")\n\n    # noinspection t\n    def _fix(d):\n        \"\"\"fix the dict in place, recursively, standardizing on a list of dict even if there's only one entry.\"\"\"\n        # if it's a dict, descend to fix\n        if isinstance(d, dict):\n            for k, v in d.items():\n                # @keys are properties of elements, non-@keys are elements\n                if not k.startswith(\"@\"):\n                    if isinstance(v, dict):\n                        # THE FIX\n                        # any non-@keys should be a list of dict, even if there's just one of the element\n                        d[k] = [v]\n                        _fix(v)\n                    else:\n                        _fix(v)\n                if isinstance(v, str) and (v.startswith(\"&lt;?xml\") or v.startswith(\"&lt;?XML\")):\n                    d[k] = _fix_escaped_xml(v)\n        # if it's a list, descend to fix\n        if isinstance(d, list):\n            for v in d:\n                _fix(v)\n\n    output = xmltodict.parse(input_str)\n    _fix(output)\n    return output\n</code></pre>"},{"location":"Rules_and_Rulesets/rulesets/#rulesets","title":"Rulesets","text":""},{"location":"Rules_and_Rulesets/rulesets/#orbiter.rules.rulesets.Ruleset","title":"orbiter.rules.rulesets.Ruleset","text":"<p>A list of rules, which are evaluated to generate different types of output</p> <p>You must pass a <code>Rule</code> (or <code>dict</code> with the schema of <code>Rule</code>) <pre><code>&gt;&gt;&gt; from orbiter.rules import rule\n&gt;&gt;&gt; @rule\n... def x(val):\n...    return None\n&gt;&gt;&gt; Ruleset(ruleset=[x, {\"rule\": lambda: None}])\n... # doctest: +ELLIPSIS\nRuleset(ruleset=[Rule(...), Rule(...)])\n</code></pre></p> <p>Note</p> <p>You can't pass non-Rules <pre><code>&gt;&gt;&gt; # noinspection PyTypeChecker\n... Ruleset(ruleset=[None])\n... # doctest: +ELLIPSIS\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n</code></pre></p> <p>Parameters:</p> Name Type Description <code>ruleset</code> <code>List[Rule | Callable[[Any], Any | None]]</code> <p>List of <code>Rule</code> (or <code>dict</code> with the schema of <code>Rule</code>)</p> <p>Methods:</p> Name Description <code>apply</code> <p>Apply all rules in ruleset to a single item, in priority order, removing any <code>None</code> results.</p> <code>apply_many</code> <p>Apply a ruleset to each item in collection (such as <code>dict().items()</code>)</p>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.rules.rulesets.Ruleset.apply","title":"apply","text":"<pre><code>apply(\n    take_first: bool = False, **kwargs\n) -&gt; List[Any] | Any\n</code></pre> <p>Apply all rules in ruleset to a single item, in priority order, removing any <code>None</code> results.</p> <p>A ruleset with one rule can produce up to one result <pre><code>&gt;&gt;&gt; from orbiter.rules import rule\n\n&gt;&gt;&gt; @rule\n... def gt_4(val):\n...     return str(val) if val &gt; 4 else None\n&gt;&gt;&gt; Ruleset(ruleset=[gt_4]).apply(val=5)\n['5']\n</code></pre></p> <p>Many rules can produce many results, one for each rule. <pre><code>&gt;&gt;&gt; @rule\n... def gt_3(val):\n...    return str(val) if val &gt; 3 else None\n&gt;&gt;&gt; Ruleset(ruleset=[gt_4, gt_3]).apply(val=5)\n['5', '5']\n</code></pre></p> <p>The <code>take_first</code> flag will evaluate rules in the ruleset and return the first match <pre><code>&gt;&gt;&gt; Ruleset(ruleset=[gt_4, gt_3]).apply(val=5, take_first=True)\n'5'\n</code></pre></p> <p>If nothing matched, an empty list is returned <pre><code>&gt;&gt;&gt; @rule\n... def always_none(val):\n...     return None\n&gt;&gt;&gt; @rule\n... def more_always_none(val):\n...     return None\n&gt;&gt;&gt; Ruleset(ruleset=[always_none, more_always_none]).apply(val=5)\n[]\n</code></pre></p> <p>If nothing matched, and <code>take_first=True</code>, <code>None</code> is returned <pre><code>&gt;&gt;&gt; Ruleset(ruleset=[always_none, more_always_none]).apply(val=5, take_first=True)\n... # None\n</code></pre></p> <p>Tip</p> <p>If no input is given, an error is returned <pre><code>&gt;&gt;&gt; Ruleset(ruleset=[always_none]).apply()\nTraceback (most recent call last):\nRuntimeError: No values provided! Supply at least one key=val pair as kwargs!\n</code></pre></p> <p>Parameters:</p> Name Type Description <code>take_first</code> <code>bool</code> <p>only take the first (if any) result from the ruleset application</p> <code>kwargs</code> <p>key=val pairs to pass to the evaluated rule function</p> <p>Returns:</p> Type Description <code>List[Any] | Any | None</code> <p>List of rules that evaluated to <code>Any</code> (in priority order), or an empty list, or <code>Any</code> (if <code>take_first=True</code>)</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the Ruleset is empty or input_val is None</p> <code>RuntimeError</code> <p>if the Rule raises an exception</p> Source code in <code>orbiter/rules/rulesets.py</code> <pre><code>@validate_call\ndef apply(self, take_first: bool = False, **kwargs) -&gt; List[Any] | Any:\n    \"\"\"\n    Apply all rules in ruleset **to a single item**, in priority order, removing any `None` results.\n\n    A ruleset with one rule can produce **up to one** result\n    ```pycon\n    &gt;&gt;&gt; from orbiter.rules import rule\n\n    &gt;&gt;&gt; @rule\n    ... def gt_4(val):\n    ...     return str(val) if val &gt; 4 else None\n    &gt;&gt;&gt; Ruleset(ruleset=[gt_4]).apply(val=5)\n    ['5']\n\n    ```\n\n    Many rules can produce many results, one for each rule.\n    ```pycon\n    &gt;&gt;&gt; @rule\n    ... def gt_3(val):\n    ...    return str(val) if val &gt; 3 else None\n    &gt;&gt;&gt; Ruleset(ruleset=[gt_4, gt_3]).apply(val=5)\n    ['5', '5']\n\n    ```\n\n    The `take_first` flag will evaluate rules in the ruleset and return the first match\n    ```pycon\n    &gt;&gt;&gt; Ruleset(ruleset=[gt_4, gt_3]).apply(val=5, take_first=True)\n    '5'\n\n    ```\n\n    If nothing matched, an empty list is returned\n    ```pycon\n    &gt;&gt;&gt; @rule\n    ... def always_none(val):\n    ...     return None\n    &gt;&gt;&gt; @rule\n    ... def more_always_none(val):\n    ...     return None\n    &gt;&gt;&gt; Ruleset(ruleset=[always_none, more_always_none]).apply(val=5)\n    []\n\n    ```\n\n    If nothing matched, and `take_first=True`, `None` is returned\n    ```pycon\n    &gt;&gt;&gt; Ruleset(ruleset=[always_none, more_always_none]).apply(val=5, take_first=True)\n    ... # None\n\n    ```\n\n    !!! tip\n\n        If no input is given, an error is returned\n        ```pycon\n        &gt;&gt;&gt; Ruleset(ruleset=[always_none]).apply()\n        Traceback (most recent call last):\n        RuntimeError: No values provided! Supply at least one key=val pair as kwargs!\n\n        ```\n\n    :param take_first: only take the first (if any) result from the ruleset application\n    :type take_first: bool\n    :param kwargs: key=val pairs to pass to the evaluated rule function\n    :returns: List of rules that evaluated to `Any` (in priority order),\n                or an empty list,\n                or `Any` (if `take_first=True`)\n    :rtype: List[Any] | Any | None\n    :raises RuntimeError: if the Ruleset is empty or input_val is None\n    :raises RuntimeError: if the Rule raises an exception\n    \"\"\"\n    if not len(kwargs):\n        raise RuntimeError(\"No values provided! Supply at least one key=val pair as kwargs!\")\n    results = []\n    for _rule in self._sorted():\n        result = _rule(**kwargs)\n        should_show_input = \"val\" in kwargs and not (\n            isinstance(kwargs[\"val\"], OrbiterProject) or isinstance(kwargs[\"val\"], OrbiterDAG)\n        )\n        if result is not None:\n            logger.debug(\n                \"---------\\n\"\n                f\"[RULESET MATCHED] '{self.__class__.__module__}.{self.__class__.__name__}'\\n\"\n                f\"[RULE MATCHED] '{_rule.__name__}'\\n\"\n                f\"[INPUT] {trim_dict(kwargs) if should_show_input else '&lt;Skipping...&gt;'}\\n\"\n                f\"[RETURN] {trim_dict(result)}\\n\"\n                f\"---------\"\n            )\n            results.append(result)\n            if take_first:\n                return result\n    return None if take_first and not len(results) else results\n</code></pre>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.rules.rulesets.Ruleset.apply_many","title":"apply_many","text":"<pre><code>apply_many(\n    input_val: Collection[Any], take_first: bool = False\n) -&gt; List[List[Any]] | List[Any]\n</code></pre> <p>Apply a ruleset to each item in collection (such as <code>dict().items()</code>) and return any results that are not <code>None</code></p> <p>You can turn the output of <code>apply_many</code> into a dict, if the rule takes and returns a tuple <pre><code>&gt;&gt;&gt; from itertools import chain\n&gt;&gt;&gt; from orbiter.rules import rule\n\n&gt;&gt;&gt; @rule\n... def filter_for_type_folder(val):\n...   (key, val) = val\n...   return (key, val) if val.get('Type', '') == 'Folder' else None\n&gt;&gt;&gt; ruleset = Ruleset(ruleset=[filter_for_type_folder])\n&gt;&gt;&gt; input_dict = {\n...    \"a\": {\"Type\": \"Folder\"},\n...    \"b\": {\"Type\": \"File\"},\n...    \"c\": {\"Type\": \"Folder\"},\n... }\n&gt;&gt;&gt; dict(chain(*chain(ruleset.apply_many(input_dict.items()))))\n... # use dict(chain(*chain(...))), if using `take_first=True`, to turn many results back into dict\n{'a': {'Type': 'Folder'}, 'c': {'Type': 'Folder'}}\n&gt;&gt;&gt; dict(ruleset.apply_many(input_dict.items(), take_first=True))\n... # use dict(...) directly, if using `take_first=True`, to turn results back into dict\n{'a': {'Type': 'Folder'}, 'c': {'Type': 'Folder'}}\n</code></pre></p> <p>Tip</p> <p>You cannot pass input without length <pre><code>&gt;&gt;&gt; ruleset.apply_many({})\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nRuntimeError: Input is not Collection[Any] with length!\n</code></pre></p> <p>Parameters:</p> Name Type Description <code>input_val</code> <code>Collection[Any]</code> <p>List to evaluate ruleset over</p> <code>take_first</code> <code>bool</code> <p>Only take the first (if any) result from each ruleset application</p> <p>Returns:</p> Type Description <code>List[List[Any]] | List[Any]</code> <p>List of list with all non-null evaluations for each item or list of the first non-null evaluation for each item (if <code>take_first=True</code>)</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the Ruleset or input_vals are empty</p> <code>RuntimeError</code> <p>if the Rule raises an exception</p> Source code in <code>orbiter/rules/rulesets.py</code> <pre><code>def apply_many(\n    self,\n    input_val: Collection[Any],\n    take_first: bool = False,\n) -&gt; List[List[Any]] | List[Any]:\n    \"\"\"\n    Apply a ruleset to each item in collection (such as `dict().items()`)\n    and return any results that are not `None`\n\n    You can turn the output of `apply_many` into a dict, if the rule takes and returns a tuple\n    ```pycon\n    &gt;&gt;&gt; from itertools import chain\n    &gt;&gt;&gt; from orbiter.rules import rule\n\n    &gt;&gt;&gt; @rule\n    ... def filter_for_type_folder(val):\n    ...   (key, val) = val\n    ...   return (key, val) if val.get('Type', '') == 'Folder' else None\n    &gt;&gt;&gt; ruleset = Ruleset(ruleset=[filter_for_type_folder])\n    &gt;&gt;&gt; input_dict = {\n    ...    \"a\": {\"Type\": \"Folder\"},\n    ...    \"b\": {\"Type\": \"File\"},\n    ...    \"c\": {\"Type\": \"Folder\"},\n    ... }\n    &gt;&gt;&gt; dict(chain(*chain(ruleset.apply_many(input_dict.items()))))\n    ... # use dict(chain(*chain(...))), if using `take_first=True`, to turn many results back into dict\n    {'a': {'Type': 'Folder'}, 'c': {'Type': 'Folder'}}\n    &gt;&gt;&gt; dict(ruleset.apply_many(input_dict.items(), take_first=True))\n    ... # use dict(...) directly, if using `take_first=True`, to turn results back into dict\n    {'a': {'Type': 'Folder'}, 'c': {'Type': 'Folder'}}\n\n    ```\n    !!! tip\n\n        You cannot pass input without length\n        ```pycon\n        &gt;&gt;&gt; ruleset.apply_many({})\n        ... # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        RuntimeError: Input is not Collection[Any] with length!\n\n        ```\n    :param input_val: List to evaluate ruleset over\n    :type input_val: Collection[Any]\n    :param take_first: Only take the first (if any) result from each ruleset application\n    :type take_first: bool\n    :returns: List of list with all non-null evaluations for each item&lt;br&gt;\n              or list of the first non-null evaluation for each item (if `take_first=True`)\n    :rtype: List[List[Any]] | List[Any]\n    :raises RuntimeError: if the Ruleset or input_vals are empty\n    :raises RuntimeError: if the Rule raises an exception\n    \"\"\"\n    # Validate Input\n    if not input_val or not len(input_val):\n        raise RuntimeError(\"Input is not `Collection[Any]` with length!\")\n\n    return [\n        results[0] if take_first else results\n        for item in input_val\n        if (results := self.apply(take_first=False, val=item)) is not None and len(results)\n    ]\n</code></pre>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.rules.rulesets.DAGFilterRuleset","title":"orbiter.rules.rulesets.DAGFilterRuleset","text":"<p>               Bases: <code>Ruleset</code></p> <p>Ruleset of <code>DAGFilterRule</code></p>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.rules.rulesets.DAGRuleset","title":"orbiter.rules.rulesets.DAGRuleset","text":"<p>               Bases: <code>Ruleset</code></p> <p>Ruleset of <code>DAGRule</code></p>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.rules.rulesets.TaskFilterRuleset","title":"orbiter.rules.rulesets.TaskFilterRuleset","text":"<p>               Bases: <code>Ruleset</code></p> <p>Ruleset of <code>TaskFilterRule</code></p>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.rules.rulesets.TaskRuleset","title":"orbiter.rules.rulesets.TaskRuleset","text":"<p>               Bases: <code>Ruleset</code></p> <p>Ruleset of <code>TaskRule</code></p>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.rules.rulesets.TaskDependencyRuleset","title":"orbiter.rules.rulesets.TaskDependencyRuleset","text":"<p>               Bases: <code>Ruleset</code></p> <p>Ruleset of <code>TaskDependencyRule</code></p>"},{"location":"Rules_and_Rulesets/rulesets/#orbiter.rules.rulesets.PostProcessingRuleset","title":"orbiter.rules.rulesets.PostProcessingRuleset","text":"<p>               Bases: <code>Ruleset</code></p> <p>Ruleset of <code>PostProcessingRule</code></p>"},{"location":"Rules_and_Rulesets/template/","title":"Template","text":"<p>The following template can be utilized for creating a new TranslationRuleset</p> translation_template.py<pre><code>from __future__ import annotations\nfrom orbiter.file_types import FileTypeJSON\nfrom orbiter.objects.dag import OrbiterDAG\nfrom orbiter.objects.operators.empty import OrbiterEmptyOperator\nfrom orbiter.objects.project import OrbiterProject\nfrom orbiter.objects.task import OrbiterOperator\nfrom orbiter.objects.task_group import OrbiterTaskGroup\nfrom orbiter.rules import (\n    dag_filter_rule,\n    dag_rule,\n    task_filter_rule,\n    task_rule,\n    task_dependency_rule,\n    post_processing_rule,\n    cannot_map_rule,\n)\nfrom orbiter.rules.rulesets import (\n    DAGFilterRuleset,\n    DAGRuleset,\n    TaskFilterRuleset,\n    TaskRuleset,\n    TaskDependencyRuleset,\n    PostProcessingRuleset,\n    TranslationRuleset,\n)\n\n\n@dag_filter_rule\ndef basic_dag_filter(val: dict) -&gt; list | None:\n    \"\"\"Filter input down to a list of dictionaries that can be processed by the `@dag_rules`\"\"\"\n    if ...:\n        for k, v in val.items():\n            pass\n        return []\n    else:\n        return None\n\n\n@dag_rule\ndef basic_dag_rule(val: dict) -&gt; OrbiterDAG | None:\n    \"\"\"Translate input into an `OrbiterDAG`\"\"\"\n    if \"dag_id\" in val:\n        return OrbiterDAG(dag_id=val[\"dag_id\"], file_path=\"file.py\")\n    else:\n        return None\n\n\n@task_filter_rule\ndef basic_task_filter(val: dict) -&gt; list | None:\n    \"\"\"Filter input down to a list of dictionaries that can be processed by the `@task_rules`\"\"\"\n    if ...:\n        for k, v in val.items():\n            pass\n        return []\n    else:\n        return None\n\n\n@task_rule(priority=2)\ndef basic_task_rule(val: dict) -&gt; OrbiterOperator | OrbiterTaskGroup | None:\n    \"\"\"Translate input into an Operator (e.g. `OrbiterBashOperator`). will be applied first, with a higher priority\"\"\"\n    if \"task_id\" in val:\n        return OrbiterEmptyOperator(task_id=val[\"task_id\"])\n    else:\n        return None\n\n\n@task_dependency_rule\ndef basic_task_dependency_rule(val: OrbiterDAG) -&gt; list | None:\n    \"\"\"Translate input into a list of task dependencies\"\"\"\n    if ...:\n        for task in val.tasks.values():\n            original_task_kwargs = task.orbiter_kwargs[\"val\"]\n            for task_dependency in original_task_kwargs.get(\"task_dependencies\", []):\n                pass\n        return []\n    else:\n        return None\n\n\n@post_processing_rule\ndef basic_post_processing_rule(val: OrbiterProject) -&gt; None:\n    \"\"\"Modify the project in-place, after all other rules have applied\"\"\"\n    if ...:\n        for dag_id, dag in val.dags.items():\n            for task_id, task in dag.tasks.items():\n                pass\n\n\ntranslation_ruleset = TranslationRuleset(\n    file_type={FileTypeJSON},\n    dag_filter_ruleset=DAGFilterRuleset(ruleset=[basic_dag_filter]),\n    dag_ruleset=DAGRuleset(ruleset=[basic_dag_rule]),\n    task_filter_ruleset=TaskFilterRuleset(ruleset=[basic_task_filter]),\n    task_ruleset=TaskRuleset(ruleset=[basic_task_rule, cannot_map_rule]),\n    task_dependency_ruleset=TaskDependencyRuleset(ruleset=[basic_task_dependency_rule]),\n    post_processing_ruleset=PostProcessingRuleset(ruleset=[basic_post_processing_rule]),\n)\n</code></pre>"},{"location":"objects/","title":"Overview","text":"<p>Objects are returned from Rules during a translation, and are rendered to produce an Apache Airflow Project</p> <p>An <code>OrbiterProject</code> holds everything necessary to render an Airflow Project. It is generated by a <code>TranslationRuleset.translate_fn</code>.</p> <p></p> <p>Workflows are represented by a <code>OrbiterDAG</code> which is a Directed Acyclic Graph (of Tasks).</p> <p><code>OrbiterOperators</code> represent Airflow Tasks, which are units of work. An Operator is a pre-defined task with specific functionality.</p>"},{"location":"objects/#orbiter.objects.OrbiterBase","title":"orbiter.objects.OrbiterBase","text":"<p>AbstractBaseClass for Orbiter objects, provides a number of properties</p> <p>Parameters:</p> Name Type Description <code>imports</code> <code>List[OrbiterRequirement]</code> <p>List of OrbiterRequirement objects</p> <code>orbiter_kwargs</code> <code>dict, optional</code> <p>Optional dictionary of keyword arguments, to preserve what was originally parsed by a rule</p> <code>orbiter_conns</code> <code>Set[OrbiterConnection], optional</code> <p>Optional set of OrbiterConnection objects</p> <code>orbiter_env_vars</code> <code>Set[OrbiterEnvVar], optional</code> <p>Optional set of OrbiterEnvVar objects</p> <code>orbiter_includes</code> <code>Set[OrbiterInclude], optional</code> <p>Optional set of OrbiterInclude objects</p> <code>orbiter_vars</code> <code>Set[OrbiterVariable], optional</code> <p>Optional set of OrbiterVariable objects</p>"},{"location":"objects/project/","title":"Project","text":"<p>An <code>OrbiterProject</code> holds everything necessary to render an Airflow Project. It is generated by a <code>TranslationRuleset.translate_fn</code>.</p>"},{"location":"objects/project/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    direction LR\n\n    OrbiterProject --&gt; \"many\" OrbiterConnection\n    OrbiterProject --&gt; \"many\" OrbiterDAG\n    OrbiterProject --&gt; \"many\" OrbiterEnvVar\n    OrbiterProject --&gt; \"many\" OrbiterInclude\n    OrbiterProject --&gt; \"many\" OrbiterPool\n    OrbiterProject --&gt; \"many\" OrbiterRequirement\n    OrbiterProject --&gt; \"many\" OrbiterVariable\n    class OrbiterProject[\"orbiter.objects.project.OrbiterProject\"] {\n            connections: Dict[str, OrbiterConnection]\n            dags: Dict[str, OrbiterDAG]\n            env_vars: Dict[str, OrbiterEnvVar]\n            includes: Dict[str, OrbiterInclude]\n            pools: Dict[str, OrbiterPool]\n            requirements: Set[OrbiterRequirement]\n            variables: Dict[str, OrbiterVariable]\n    }\n    click OrbiterProject href \"#orbiter.objects.project.OrbiterProject\" \"OrbiterProject Documentation\"\n\n    class OrbiterConnection[\"orbiter.objects.connection.OrbiterConnection\"] {\n            conn_id: str\n            conn_type: str\n            **kwargs\n    }\n    click OrbiterConnection href \"#orbiter.objects.connection.OrbiterConnection\" \"OrbiterConnection Documentation\"\n\n    OrbiterDAG --&gt; \"many\" OrbiterInclude\n    OrbiterDAG --&gt; \"many\" OrbiterConnection\n    OrbiterDAG --&gt; \"many\" OrbiterEnvVar\n    OrbiterDAG --&gt; \"many\" OrbiterRequirement\n    OrbiterDAG --&gt; \"many\" OrbiterVariable\n    class OrbiterDAG[\"orbiter.objects.dag.OrbiterDAG\"] {\n            imports: List[OrbiterRequirement]\n            file_path: str\n            dag_id: str\n            schedule: str | OrbiterTimetable | None\n            catchup: bool\n            start_date: DateTime\n            tags: List[str]\n            default_args: Dict[str, Any]\n            params: Dict[str, Any]\n            doc_md: str | None\n            tasks: Dict[str, OrbiterOperator]\n            kwargs: dict\n            orbiter_kwargs: dict\n            orbiter_conns: Set[OrbiterConnection]\n            orbiter_vars: Set[OrbiterVariable]\n            orbiter_env_vars: Set[OrbiterEnvVar]\n            orbiter_includes: Set[OrbiterInclude]\n    }\n\n    class OrbiterEnvVar[\"orbiter.objects.env_var.OrbiterEnvVar\"] {\n            key: str\n            value: str\n    }\n    click OrbiterEnvVar href \"#orbiter.objects.env_var.OrbiterEnvVar\" \"OrbiterEnvVar Documentation\"\n\n    class OrbiterInclude[\"orbiter.objects.include.OrbiterInclude\"] {\n            filepath: str\n            contents: str\n    }\n    click OrbiterInclude href \"#orbiter.objects.include.OrbiterInclude\" \"OrbiterInclude Documentation\"\n\n    class OrbiterPool[\"orbiter.objects.pool.OrbiterPool\"] {\n            name: str\n            description: str | None\n            slots: int | None\n    }\n    click OrbiterPool href \"#orbiter.objects.pool.OrbiterPool\" \"OrbiterPool Documentation\"\n\n    class OrbiterRequirement[\"orbiter.objects.requirement.OrbiterRequirement\"] {\n            package: str | None\n            module: str | None\n            names: List[str] | None\n            sys_package: str | None\n    }\n    click OrbiterRequirement href \"#orbiter.objects.requirement.OrbiterRequirement\" \"OrbiterRequirement Documentation\"\n\n    class OrbiterVariable[\"orbiter.objects.variable.OrbiterVariable\"] {\n            key: str\n            value: str\n    }\n    click OrbiterVariable href \"#orbiter.objects.variable.OrbiterVariable\" \"OrbiterVariable Documentation\"\n</code></pre>"},{"location":"objects/project/#orbiter.objects.connection.OrbiterConnection","title":"orbiter.objects.connection.OrbiterConnection","text":"<p>An Airflow Connection, rendered to an <code>airflow_settings.yaml</code> file.</p> <p>See also other Connection documentation.</p> <pre><code>&gt;&gt;&gt; OrbiterConnection(\n...     conn_id=\"my_conn_id\", conn_type=\"mysql\", host=\"localhost\", port=3306, login=\"root\"\n... ).render()\n{'conn_id': 'my_conn_id', 'conn_type': 'mysql', 'conn_host': 'localhost', 'conn_port': 3306, 'conn_login': 'root'}\n</code></pre> <p>Note</p> <p>Use the utility <code>conn_id</code> function to generate both an <code>OrbiterConnection</code> and connection property for an operator</p> <pre><code>from orbiter.objects import conn_id\n\nOrbiterTask(\n    ...,\n    **conn_id(\"my_conn_id\", conn_type=\"mysql\"),\n)\n</code></pre> <p>Parameters:</p> Name Type Description <code>conn_id</code> <code>str</code> <p>The ID of the connection</p> <code>conn_type</code> <code>str, optional</code> <p>The type of the connection, always lowercase. Defaults to 'generic'</p> <code>**kwargs</code> <p>Additional properties for the connection</p>"},{"location":"objects/project/#orbiter.objects.env_var.OrbiterEnvVar","title":"orbiter.objects.env_var.OrbiterEnvVar","text":"<p>Represents an Environmental Variable, renders to a line in <code>.env</code> file</p> <pre><code>&gt;&gt;&gt; OrbiterEnvVar(key=\"foo\", value=\"bar\").render()\n'foo=bar'\n</code></pre> <p>Parameters:</p> Name Type Description <code>key</code> <code>str</code> <p>The key of the environment variable</p> <code>value</code> <code>str</code> <p>The value of the environment variable</p>"},{"location":"objects/project/#orbiter.objects.include.OrbiterInclude","title":"orbiter.objects.include.OrbiterInclude","text":"<p>Represents an included file in an <code>/include</code> directory</p> <p>Parameters:</p> Name Type Description <code>filepath</code> <code>str</code> <p>The relative path (from the output directory) to write the file to</p> <code>contents</code> <code>str</code> <p>The contents of the file</p>"},{"location":"objects/project/#orbiter.objects.pool.OrbiterPool","title":"orbiter.objects.pool.OrbiterPool","text":"<p>An Airflow Pool, rendered to an <code>airflow_settings.yaml</code> file.</p> <pre><code>&gt;&gt;&gt; OrbiterPool(name=\"foo\", description=\"bar\", slots=5).render()\n{'pool_name': 'foo', 'pool_description': 'bar', 'pool_slot': 5}\n</code></pre> <p>Note</p> <p>Use the utility <code>pool</code> function to easily generate both an <code>OrbiterPool</code> and <code>pool</code> property for an operator</p> <pre><code>from orbiter.objects import pool\n\nOrbiterTask(\n    ...,\n    **pool(\"my_pool\"),\n)\n</code></pre> <p>Parameters:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the pool</p> <code>description</code> <code>str, optional</code> <p>The description of the pool</p> <code>slots</code> <code>int, optional</code> <p>The number of slots in the pool. Defaults to 128</p>"},{"location":"objects/project/#orbiter.objects.requirement.OrbiterRequirement","title":"orbiter.objects.requirement.OrbiterRequirement","text":"<p>A requirement for a project (e.g. <code>apache-airflow-providers-google</code>), and it's representation in the DAG file.</p> <p>Renders via the DAG File (as an import statement), <code>requirements.txt</code>, and <code>packages.txt</code></p> <p>Tip</p> <p>If a given requirement has multiple packages required, it can be defined as multiple <code>OrbiterRequirement</code> objects.</p> <p>Example: <pre><code>OrbiterTask(\n    ...,\n    imports=[\n        OrbiterRequirement(package=\"apache-airflow-providers-google\", ...),\n        OrbiterRequirement(package=\"bigquery\", sys_package=\"mysql\", ...),\n    ],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description <code>package</code> <code>str, optional</code> <p>e.g. <code>\"apache-airflow-providers-google\"</code></p> <code>module</code> <code>str, optional</code> <p>e.g. <code>\"airflow.providers.google.cloud.operators.bigquery\"</code>, defaults to <code>None</code></p> <code>names</code> <code>List[str], optional</code> <p>e.g. <code>[\"BigQueryCreateEmptyDatasetOperator\"]</code>, defaults to <code>[]</code></p> <code>sys_package</code> <code>Set[str], optional</code> <p>e.g. <code>\"mysql\"</code> - represents a Debian system package</p>"},{"location":"objects/project/#orbiter.objects.variable.OrbiterVariable","title":"orbiter.objects.variable.OrbiterVariable","text":"<p>An Airflow Variable, rendered to an <code>airflow_settings.yaml</code> file.</p> <pre><code>&gt;&gt;&gt; OrbiterVariable(key=\"foo\", value=\"bar\").render()\n{'variable_value': 'bar', 'variable_name': 'foo'}\n</code></pre> <p>Parameters:</p> Name Type Description <code>key</code> <code>str</code> <p>The key of the variable</p> <code>value</code> <code>str</code> <p>The value of the variable</p>"},{"location":"objects/project/#orbiter.objects.project.OrbiterProject","title":"orbiter.objects.project.OrbiterProject","text":"<pre><code>OrbiterProject()\n</code></pre> <p>Holds everything necessary to render an Airflow Project. This is generated by a <code>TranslationRuleset.translate_fn</code>.</p> <p>Tip</p> <p>They can be added together <pre><code>&gt;&gt;&gt; OrbiterProject() + OrbiterProject()\nOrbiterProject(dags=[], requirements=[], pools=[], connections=[], variables=[], env_vars=[])\n</code></pre></p> <p>And compared <pre><code>&gt;&gt;&gt; OrbiterProject() == OrbiterProject()\nTrue\n</code></pre></p> <p>Parameters:</p> Name Type Description <code>connections</code> <code>Dict[str, OrbiterConnection]</code> <p>A dictionary of OrbiterConnections</p> <code>dags</code> <code>Dict[str, OrbiterDAG]</code> <p>A dictionary of OrbiterDAGs</p> <code>env_vars</code> <code>Dict[str, OrbiterEnvVar]</code> <p>A dictionary of OrbiterEnvVars</p> <code>includes</code> <code>Dict[str, OrbiterInclude]</code> <p>A dictionary of OrbiterIncludes</p> <code>pools</code> <code>Dict[str, OrbiterPool]</code> <p>A dictionary of OrbiterPools</p> <code>requirements</code> <code>Set[OrbiterRequirement]</code> <p>A set of OrbiterRequirement</p> <code>variables</code> <code>Dict[str, OrbiterVariable]</code> <p>A dictionary of OrbiterVariables</p> <p>Methods:</p> Name Description <code>add_connections</code> <p>Add <code>OrbiterConnections</code> to the Project</p> <code>add_dags</code> <p>Add OrbiterDAGs</p> <code>add_env_vars</code> <p>Add OrbiterEnvVars to the Project</p> <code>add_includes</code> <p>Add OrbiterIncludes to the Project</p> <code>add_pools</code> <p>Add OrbiterPool to the Project</p> <code>add_requirements</code> <p>Add OrbiterRequirement to the Project</p> <code>add_variables</code> <p>Add OrbiterVariables to the Project</p> <code>analyze</code> <p>Print an analysis of the project to the console.</p> Source code in <code>orbiter/objects/project.py</code> <pre><code>def __init__(self):\n    self.dags: Dict[str, OrbiterDAG] = dict()\n    self.requirements: Set[OrbiterRequirement] = set()\n    self.pools: Dict[str, OrbiterPool] = dict()\n    self.connections: Dict[str, OrbiterConnection] = dict()\n    self.variables: Dict[str, OrbiterVariable] = dict()\n    self.env_vars: Dict[str, OrbiterEnvVar] = dict()\n    self.includes: Dict[str, OrbiterInclude] = dict()\n</code></pre>"},{"location":"objects/project/#orbiter.objects.project.OrbiterProject.add_connections","title":"add_connections","text":"<pre><code>add_connections(\n    connections: (\n        OrbiterConnection | Iterable[OrbiterConnection]\n    ),\n) -&gt; \"OrbiterProject\"\n</code></pre> <p>Add <code>OrbiterConnections</code> to the Project or override an existing connection with new properties</p> <pre><code>&gt;&gt;&gt; OrbiterProject().add_connections(OrbiterConnection(conn_id='foo')).connections\n{'foo': OrbiterConnection(conn_id=foo, conn_type=generic)}\n\n&gt;&gt;&gt; OrbiterProject().add_connections(\n...     [OrbiterConnection(conn_id='foo'), OrbiterConnection(conn_id='bar')]\n... ).connections\n{'foo': OrbiterConnection(conn_id=foo, conn_type=generic), 'bar': OrbiterConnection(conn_id=bar, conn_type=generic)}\n</code></pre> <p>Tip</p> <p>Validation requires an <code>OrbiterConnection</code> to be passed <pre><code>&gt;&gt;&gt; # noinspection PyTypeChecker\n... OrbiterProject().add_connections('foo')\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n&gt;&gt;&gt; # noinspection PyTypeChecker\n&gt;&gt;&gt; OrbiterProject().add_connections(['foo'])\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n</code></pre></p> <p>Parameters:</p> Name Type Description <code>connections</code> <code>OrbiterConnection | Iterable[OrbiterConnection]</code> <p>List of <code>OrbiterConnections</code></p> <p>Returns:</p> Type Description <code>OrbiterProject</code> <p>self</p> Source code in <code>orbiter/objects/project.py</code> <pre><code>def add_connections(self, connections: OrbiterConnection | Iterable[OrbiterConnection]) -&gt; \"OrbiterProject\":\n    \"\"\"Add [`OrbiterConnections`][orbiter.objects.connection.OrbiterConnection] to the Project\n    or override an existing connection with new properties\n\n    ```pycon\n    &gt;&gt;&gt; OrbiterProject().add_connections(OrbiterConnection(conn_id='foo')).connections\n    {'foo': OrbiterConnection(conn_id=foo, conn_type=generic)}\n\n    &gt;&gt;&gt; OrbiterProject().add_connections(\n    ...     [OrbiterConnection(conn_id='foo'), OrbiterConnection(conn_id='bar')]\n    ... ).connections\n    {'foo': OrbiterConnection(conn_id=foo, conn_type=generic), 'bar': OrbiterConnection(conn_id=bar, conn_type=generic)}\n\n    ```\n\n    !!! tip\n\n        Validation requires an `OrbiterConnection` to be passed\n        ```pycon\n        &gt;&gt;&gt; # noinspection PyTypeChecker\n        ... OrbiterProject().add_connections('foo')\n        ... # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        pydantic_core._pydantic_core.ValidationError: ...\n        &gt;&gt;&gt; # noinspection PyTypeChecker\n        &gt;&gt;&gt; OrbiterProject().add_connections(['foo'])\n        ... # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        pydantic_core._pydantic_core.ValidationError: ...\n\n        ```\n\n    :param connections: List of [`OrbiterConnections`][orbiter.objects.connection.OrbiterConnection]\n    :type connections: List[OrbiterConnection] | OrbiterConnection\n    :return: self\n    :rtype: OrbiterProject\n    \"\"\"  # noqa: E501\n    for connection in [connections] if isinstance(connections, OrbiterConnection) else connections:\n        self.connections[connection.conn_id] = connection\n    return self\n</code></pre>"},{"location":"objects/project/#orbiter.objects.project.OrbiterProject.add_dags","title":"add_dags","text":"<pre><code>add_dags(\n    dags: OrbiterDAG | Iterable[OrbiterDAG],\n) -&gt; \"OrbiterProject\"\n</code></pre> <p>Add OrbiterDAGs (and any OrbiterRequirement, OrbiterConns, OrbiterVars, OrbiterPools, OrbiterEnvVars, etc.) to the Project.</p> <pre><code>&gt;&gt;&gt; OrbiterProject().add_dags(OrbiterDAG(dag_id='foo', file_path=\"\")).dags['foo'].repr()\n'OrbiterDAG(dag_id=foo, schedule=None, start_date=1970-01-01 00:00:00, catchup=False)'\n\n&gt;&gt;&gt; dags = OrbiterProject().add_dags(\n...     [OrbiterDAG(dag_id='foo', file_path=\"\"), OrbiterDAG(dag_id='bar', file_path=\"\")]\n... ).dags; dags['foo'].repr(), dags['bar'].repr()\n... # doctest: +NORMALIZE_WHITESPACE\n('OrbiterDAG(dag_id=foo, schedule=None, start_date=1970-01-01 00:00:00, catchup=False)', 'OrbiterDAG(dag_id=bar, schedule=None, start_date=1970-01-01 00:00:00, catchup=False)')\n\n&gt;&gt;&gt; # An example adding a little of everything, including deeply nested things\n... from orbiter.objects.operators.bash import OrbiterBashOperator\n&gt;&gt;&gt; from orbiter.objects.timetables.multi_cron_timetable import OrbiterMultiCronTimetable\n&gt;&gt;&gt; from orbiter.objects.callbacks.smtp import OrbiterSmtpNotifierCallback\n&gt;&gt;&gt; OrbiterProject().add_dags(OrbiterDAG(\n...     dag_id='foo', file_path=\"\",\n...     orbiter_env_vars={OrbiterEnvVar(key=\"foo\", value=\"bar\")},\n...     orbiter_includes={OrbiterInclude(filepath='foo.txt', contents=\"Hello, World!\")},\n...     schedule=OrbiterMultiCronTimetable(cron_defs=[\"0 */5 * * *\", \"0 */3 * * *\"]),\n...     ).add_tasks(\n...         OrbiterTaskGroup(task_group_id=\"foo\").add_tasks(OrbiterBashOperator(\n...             task_id='foo', bash_command='echo \"Hello, World!\"',\n...             orbiter_pool=OrbiterPool(name='foo', slots=1),\n...             orbiter_vars={OrbiterVariable(key='foo', value='bar')},\n...             orbiter_conns={OrbiterConnection(conn_id='foo')},\n...             orbiter_env_vars={OrbiterEnvVar(key='foo', value='bar')},\n...             on_success_callback=OrbiterSmtpNotifierCallback(\n...                 to=\"foo@bar.com\",\n...                 smtp_conn_id=\"SMTP\",\n...                 orbiter_conns={OrbiterConnection(conn_id=\"SMTP\", conn_type=\"smtp\")}\n...             )\n...         )\n...     )\n... ))\n... # doctest: +NORMALIZE_WHITESPACE\nOrbiterProject(dags=[foo],\nrequirements=[OrbiterRequirement(names=[DAG], package=apache-airflow, module=airflow, sys_package=None),\nOrbiterRequirement(names=[BashOperator], package=apache-airflow, module=airflow.operators.bash, sys_package=None),\nOrbiterRequirement(names=[send_smtp_notification], package=apache-airflow-providers-smtp, module=airflow.providers.smtp.notifications.smtp, sys_package=None),\nOrbiterRequirement(names=[TaskGroup], package=apache-airflow, module=airflow.utils.task_group, sys_package=None),\nOrbiterRequirement(names=[MultiCronTimetable], package=croniter, module=include.multi_cron_timetable, sys_package=None),\nOrbiterRequirement(names=[DateTime,Timezone], package=pendulum, module=pendulum, sys_package=None)],\npools=['foo'],\nconnections=['SMTP', 'foo'],\nvariables=['foo'],\nenv_vars=['foo'])\n</code></pre> <p>Tip</p> <p>Validation requires an <code>OrbiterDAG</code> to be passed <pre><code>&gt;&gt;&gt; # noinspection PyTypeChecker\n... OrbiterProject().add_dags('foo')\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n&gt;&gt;&gt; # noinspection PyTypeChecker\n&gt;&gt;&gt; OrbiterProject().add_dags(['foo'])\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n</code></pre></p> <p>Parameters:</p> Name Type Description <code>dags</code> <code>OrbiterDAG | Iterable[OrbiterDAG]</code> <p>List of OrbiterDAGs</p> <p>Returns:</p> Type Description <code>OrbiterProject</code> <p>self</p> Source code in <code>orbiter/objects/project.py</code> <pre><code>def add_dags(self, dags: OrbiterDAG | Iterable[OrbiterDAG]) -&gt; \"OrbiterProject\":\n    \"\"\"Add [OrbiterDAGs][orbiter.objects.dag.OrbiterDAG]\n    (and any [OrbiterRequirement][orbiter.objects.requirement.OrbiterRequirement],\n    [OrbiterConns][orbiter.objects.connection.OrbiterConnection],\n    [OrbiterVars][orbiter.objects.variable.OrbiterVariable],\n    [OrbiterPools][orbiter.objects.pool.OrbiterPool],\n    [OrbiterEnvVars][orbiter.objects.env_var.OrbiterEnvVar], etc.)\n    to the Project.\n\n    ```pycon\n    &gt;&gt;&gt; OrbiterProject().add_dags(OrbiterDAG(dag_id='foo', file_path=\"\")).dags['foo'].repr()\n    'OrbiterDAG(dag_id=foo, schedule=None, start_date=1970-01-01 00:00:00, catchup=False)'\n\n    &gt;&gt;&gt; dags = OrbiterProject().add_dags(\n    ...     [OrbiterDAG(dag_id='foo', file_path=\"\"), OrbiterDAG(dag_id='bar', file_path=\"\")]\n    ... ).dags; dags['foo'].repr(), dags['bar'].repr()\n    ... # doctest: +NORMALIZE_WHITESPACE\n    ('OrbiterDAG(dag_id=foo, schedule=None, start_date=1970-01-01 00:00:00, catchup=False)', 'OrbiterDAG(dag_id=bar, schedule=None, start_date=1970-01-01 00:00:00, catchup=False)')\n\n    &gt;&gt;&gt; # An example adding a little of everything, including deeply nested things\n    ... from orbiter.objects.operators.bash import OrbiterBashOperator\n    &gt;&gt;&gt; from orbiter.objects.timetables.multi_cron_timetable import OrbiterMultiCronTimetable\n    &gt;&gt;&gt; from orbiter.objects.callbacks.smtp import OrbiterSmtpNotifierCallback\n    &gt;&gt;&gt; OrbiterProject().add_dags(OrbiterDAG(\n    ...     dag_id='foo', file_path=\"\",\n    ...     orbiter_env_vars={OrbiterEnvVar(key=\"foo\", value=\"bar\")},\n    ...     orbiter_includes={OrbiterInclude(filepath='foo.txt', contents=\"Hello, World!\")},\n    ...     schedule=OrbiterMultiCronTimetable(cron_defs=[\"0 */5 * * *\", \"0 */3 * * *\"]),\n    ...     ).add_tasks(\n    ...         OrbiterTaskGroup(task_group_id=\"foo\").add_tasks(OrbiterBashOperator(\n    ...             task_id='foo', bash_command='echo \"Hello, World!\"',\n    ...             orbiter_pool=OrbiterPool(name='foo', slots=1),\n    ...             orbiter_vars={OrbiterVariable(key='foo', value='bar')},\n    ...             orbiter_conns={OrbiterConnection(conn_id='foo')},\n    ...             orbiter_env_vars={OrbiterEnvVar(key='foo', value='bar')},\n    ...             on_success_callback=OrbiterSmtpNotifierCallback(\n    ...                 to=\"foo@bar.com\",\n    ...                 smtp_conn_id=\"SMTP\",\n    ...                 orbiter_conns={OrbiterConnection(conn_id=\"SMTP\", conn_type=\"smtp\")}\n    ...             )\n    ...         )\n    ...     )\n    ... ))\n    ... # doctest: +NORMALIZE_WHITESPACE\n    OrbiterProject(dags=[foo],\n    requirements=[OrbiterRequirement(names=[DAG], package=apache-airflow, module=airflow, sys_package=None),\n    OrbiterRequirement(names=[BashOperator], package=apache-airflow, module=airflow.operators.bash, sys_package=None),\n    OrbiterRequirement(names=[send_smtp_notification], package=apache-airflow-providers-smtp, module=airflow.providers.smtp.notifications.smtp, sys_package=None),\n    OrbiterRequirement(names=[TaskGroup], package=apache-airflow, module=airflow.utils.task_group, sys_package=None),\n    OrbiterRequirement(names=[MultiCronTimetable], package=croniter, module=include.multi_cron_timetable, sys_package=None),\n    OrbiterRequirement(names=[DateTime,Timezone], package=pendulum, module=pendulum, sys_package=None)],\n    pools=['foo'],\n    connections=['SMTP', 'foo'],\n    variables=['foo'],\n    env_vars=['foo'])\n\n    ```\n\n    !!! tip\n\n        Validation requires an `OrbiterDAG` to be passed\n        ```pycon\n        &gt;&gt;&gt; # noinspection PyTypeChecker\n        ... OrbiterProject().add_dags('foo')\n        ... # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        pydantic_core._pydantic_core.ValidationError: ...\n        &gt;&gt;&gt; # noinspection PyTypeChecker\n        &gt;&gt;&gt; OrbiterProject().add_dags(['foo'])\n        ... # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        pydantic_core._pydantic_core.ValidationError: ...\n\n        ```\n\n    :param dags: List of [OrbiterDAGs][orbiter.objects.dag.OrbiterDAG]\n    :type dags: List[OrbiterDAG] | OrbiterDAG\n    :return: self\n    :rtype: OrbiterProject\n    \"\"\"  # noqa: E501\n\n    # noinspection t\n    def _add_recursively(\n        things: Iterable[OrbiterOperator | OrbiterTaskGroup | OrbiterCallback | OrbiterTimetable | OrbiterDAG],\n    ):\n        for thing in things:\n            if isinstance(thing, str):\n                continue\n            if hasattr(thing, \"orbiter_pool\") and (pool := thing.orbiter_pool):\n                self.add_pools(pool)\n            if hasattr(thing, \"orbiter_conns\") and (conns := thing.orbiter_conns):\n                self.add_connections(conns)\n            if hasattr(thing, \"orbiter_vars\") and (variables := thing.orbiter_vars):\n                self.add_variables(variables)\n            if hasattr(thing, \"orbiter_env_vars\") and (env_vars := thing.orbiter_env_vars):\n                self.add_env_vars(env_vars)\n            if hasattr(thing, \"orbiter_includes\") and (includes := thing.orbiter_includes):\n                self.add_includes(includes)\n            if hasattr(thing, \"imports\") and (imports := thing.imports):\n                self.add_requirements(imports)\n            if isinstance(thing, OrbiterTaskGroup) and (tasks := thing.tasks):\n                _add_recursively(tasks.values())\n            if hasattr(thing, \"__dict__\") or hasattr(thing, \"model_extra\"):\n                # If it's a pydantic model or dict, check its properties for more things to add\n                _add_recursively(\n                    (\n                        (getattr(thing, \"__dict__\", {}) or dict()) | (getattr(thing, \"model_extra\", {}) or dict())\n                    ).values()\n                )\n\n    for dag in [dags] if isinstance(dags, OrbiterDAG) else dags:\n        dag_id = dag.dag_id\n\n        # Add or update the DAG\n        if dag_id in self.dags:\n            self.dags[dag_id] += dag\n        else:\n            self.dags[dag_id] = dag\n\n        # Add anything that might be in the tasks of the DAG - such as imports, Connections, etc\n        _add_recursively((dag.tasks or {}).values())\n\n        # Add anything that might be in the `dag.schedule` - such as Includes, Timetables, Connections, etc\n        _add_recursively([dag])\n    return self\n</code></pre>"},{"location":"objects/project/#orbiter.objects.project.OrbiterProject.add_env_vars","title":"add_env_vars","text":"<pre><code>add_env_vars(\n    env_vars: OrbiterEnvVar | Iterable[OrbiterEnvVar],\n) -&gt; \"OrbiterProject\"\n</code></pre> <p>Add OrbiterEnvVars to the Project or override an existing env var with new properties</p> <pre><code>&gt;&gt;&gt; OrbiterProject().add_env_vars(OrbiterEnvVar(key=\"foo\", value=\"bar\")).env_vars\n{'foo': OrbiterEnvVar(key='foo', value='bar')}\n\n&gt;&gt;&gt; OrbiterProject().add_env_vars([OrbiterEnvVar(key=\"foo\", value=\"bar\")]).env_vars\n{'foo': OrbiterEnvVar(key='foo', value='bar')}\n</code></pre> <p>Tip</p> <p>Validation requires an <code>OrbiterEnvVar</code> to be passed <pre><code>&gt;&gt;&gt; # noinspection PyTypeChecker\n... OrbiterProject().add_env_vars('foo')\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n\n&gt;&gt;&gt; # noinspection PyTypeChecker\n... OrbiterProject().add_env_vars(['foo'])\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n</code></pre></p> <p>Parameters:</p> Name Type Description <code>env_vars</code> <code>OrbiterEnvVar | Iterable[OrbiterEnvVar]</code> <p>List of OrbiterEnvVar</p> <p>Returns:</p> Type Description <code>OrbiterProject</code> <p>self</p> Source code in <code>orbiter/objects/project.py</code> <pre><code>def add_env_vars(self, env_vars: OrbiterEnvVar | Iterable[OrbiterEnvVar]) -&gt; \"OrbiterProject\":\n    \"\"\"\n    Add [OrbiterEnvVars][orbiter.objects.env_var.OrbiterEnvVar] to the Project\n    or override an existing env var with new properties\n\n    ```pycon\n    &gt;&gt;&gt; OrbiterProject().add_env_vars(OrbiterEnvVar(key=\"foo\", value=\"bar\")).env_vars\n    {'foo': OrbiterEnvVar(key='foo', value='bar')}\n\n    &gt;&gt;&gt; OrbiterProject().add_env_vars([OrbiterEnvVar(key=\"foo\", value=\"bar\")]).env_vars\n    {'foo': OrbiterEnvVar(key='foo', value='bar')}\n\n    ```\n\n    !!! tip\n\n        Validation requires an `OrbiterEnvVar` to be passed\n        ```pycon\n        &gt;&gt;&gt; # noinspection PyTypeChecker\n        ... OrbiterProject().add_env_vars('foo')\n        ... # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        pydantic_core._pydantic_core.ValidationError: ...\n\n        &gt;&gt;&gt; # noinspection PyTypeChecker\n        ... OrbiterProject().add_env_vars(['foo'])\n        ... # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        pydantic_core._pydantic_core.ValidationError: ...\n\n        ```\n\n    :param env_vars: List of [OrbiterEnvVar][orbiter.objects.env_var.OrbiterEnvVar]\n    :type env_vars: List[OrbiterEnvVar] | OrbiterEnvVar\n    :return: self\n    :rtype: OrbiterProject\n    \"\"\"\n    for env_var in [env_vars] if isinstance(env_vars, OrbiterEnvVar) else env_vars:\n        self.env_vars[env_var.key] = env_var\n    return self\n</code></pre>"},{"location":"objects/project/#orbiter.objects.project.OrbiterProject.add_includes","title":"add_includes","text":"<pre><code>add_includes(\n    includes: OrbiterInclude | Iterable[OrbiterInclude],\n) -&gt; \"OrbiterProject\"\n</code></pre> <p>Add OrbiterIncludes to the Project or override an existing OrbiterInclude with new properties</p> <pre><code>&gt;&gt;&gt; OrbiterProject().add_includes(OrbiterInclude(filepath=\"foo\", contents=\"bar\")).includes\n{'foo': OrbiterInclude(filepath='foo', contents='bar')}\n\n&gt;&gt;&gt; OrbiterProject().add_includes([OrbiterInclude(filepath=\"foo\", contents=\"bar\")]).includes\n{'foo': OrbiterInclude(filepath='foo', contents='bar')}\n</code></pre> <p>Tip</p> <p>Validation requires an <code>OrbiterInclude</code> to be passed <pre><code>&gt;&gt;&gt; # noinspection PyTypeChecker\n... OrbiterProject().add_includes('foo')\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n\n&gt;&gt;&gt; # noinspection PyTypeChecker\n... OrbiterProject().add_includes(['foo'])\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n</code></pre></p> <p>Parameters:</p> Name Type Description <code>includes</code> <code>OrbiterInclude | Iterable[OrbiterInclude]</code> <p>List of OrbiterIncludes</p> <p>Returns:</p> Type Description <code>OrbiterProject</code> <p>self</p> Source code in <code>orbiter/objects/project.py</code> <pre><code>def add_includes(self, includes: OrbiterInclude | Iterable[OrbiterInclude]) -&gt; \"OrbiterProject\":\n    \"\"\"Add [OrbiterIncludes][orbiter.objects.include.OrbiterInclude] to the Project\n    or override an existing [OrbiterInclude][orbiter.objects.include.OrbiterInclude] with new properties\n\n    ```pycon\n    &gt;&gt;&gt; OrbiterProject().add_includes(OrbiterInclude(filepath=\"foo\", contents=\"bar\")).includes\n    {'foo': OrbiterInclude(filepath='foo', contents='bar')}\n\n    &gt;&gt;&gt; OrbiterProject().add_includes([OrbiterInclude(filepath=\"foo\", contents=\"bar\")]).includes\n    {'foo': OrbiterInclude(filepath='foo', contents='bar')}\n\n    ```\n\n    !!! tip\n\n        Validation requires an `OrbiterInclude` to be passed\n        ```pycon\n        &gt;&gt;&gt; # noinspection PyTypeChecker\n        ... OrbiterProject().add_includes('foo')\n        ... # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        pydantic_core._pydantic_core.ValidationError: ...\n\n        &gt;&gt;&gt; # noinspection PyTypeChecker\n        ... OrbiterProject().add_includes(['foo'])\n        ... # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        pydantic_core._pydantic_core.ValidationError: ...\n\n        ```\n    :param includes: List of [OrbiterIncludes][orbiter.objects.include.OrbiterInclude]\n    :type includes: List[OrbiterInclude]\n    :return: self\n    :rtype: OrbiterProject\n    \"\"\"\n    for include in [includes] if isinstance(includes, OrbiterInclude) else includes:\n        self.includes[include.filepath] = include\n    return self\n</code></pre>"},{"location":"objects/project/#orbiter.objects.project.OrbiterProject.add_pools","title":"add_pools","text":"<pre><code>add_pools(\n    pools: OrbiterPool | Iterable[OrbiterPool],\n) -&gt; \"OrbiterProject\"\n</code></pre> <p>Add OrbiterPool to the Project or override existing pools with new properties</p> <pre><code>&gt;&gt;&gt; OrbiterProject().add_pools(OrbiterPool(name=\"foo\", slots=1)).pools\n{'foo': OrbiterPool(name='foo', description='', slots=1)}\n\n&gt;&gt;&gt; ( OrbiterProject()\n...     .add_pools([OrbiterPool(name=\"foo\", slots=1)])\n...     .add_pools([OrbiterPool(name=\"foo\", slots=2)])\n...     .pools\n... )\n{'foo': OrbiterPool(name='foo', description='', slots=2)}\n</code></pre> <p>Tip</p> <p>Validation requires an <code>OrbiterPool</code> to be passed <pre><code>&gt;&gt;&gt; # noinspection PyTypeChecker\n... OrbiterProject().add_pools('foo')\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n&gt;&gt;&gt; # noinspection PyTypeChecker\n... OrbiterProject().add_pools(['foo'])\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n</code></pre></p> <p>Parameters:</p> Name Type Description <code>pools</code> <code>OrbiterPool | Iterable[OrbiterPool]</code> <p>List of OrbiterPools</p> <p>Returns:</p> Type Description <code>OrbiterProject</code> <p>self</p> Source code in <code>orbiter/objects/project.py</code> <pre><code>def add_pools(self, pools: OrbiterPool | Iterable[OrbiterPool]) -&gt; \"OrbiterProject\":\n    \"\"\"Add [OrbiterPool][orbiter.objects.pool.OrbiterPool] to the Project\n    or override existing pools with new properties\n\n    ```pycon\n    &gt;&gt;&gt; OrbiterProject().add_pools(OrbiterPool(name=\"foo\", slots=1)).pools\n    {'foo': OrbiterPool(name='foo', description='', slots=1)}\n\n    &gt;&gt;&gt; ( OrbiterProject()\n    ...     .add_pools([OrbiterPool(name=\"foo\", slots=1)])\n    ...     .add_pools([OrbiterPool(name=\"foo\", slots=2)])\n    ...     .pools\n    ... )\n    {'foo': OrbiterPool(name='foo', description='', slots=2)}\n\n    ```\n\n    !!! tip\n\n        Validation requires an `OrbiterPool` to be passed\n        ```pycon\n        &gt;&gt;&gt; # noinspection PyTypeChecker\n        ... OrbiterProject().add_pools('foo')\n        ... # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        pydantic_core._pydantic_core.ValidationError: ...\n        &gt;&gt;&gt; # noinspection PyTypeChecker\n        ... OrbiterProject().add_pools(['foo'])\n        ... # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        pydantic_core._pydantic_core.ValidationError: ...\n\n        ```\n    :param pools: List of [OrbiterPools][orbiter.objects.pool.OrbiterPool]\n    :type pools: List[OrbiterPool] | OrbiterPool\n    :return: self\n    :rtype: OrbiterProject\n    \"\"\"\n    for pool in [pools] if isinstance(pools, OrbiterPool) else pools:\n        if pool.name in self.pools:\n            self.pools[pool.name] += pool\n        else:\n            self.pools[pool.name] = pool\n    return self\n</code></pre>"},{"location":"objects/project/#orbiter.objects.project.OrbiterProject.add_requirements","title":"add_requirements","text":"<pre><code>add_requirements(\n    requirements: (\n        OrbiterRequirement | Iterable[OrbiterRequirement]\n    ),\n) -&gt; \"OrbiterProject\"\n</code></pre> <p>Add OrbiterRequirement to the Project or override an existing requirement with new properties</p> <pre><code>&gt;&gt;&gt; OrbiterProject().add_requirements(\n...    OrbiterRequirement(package=\"apache-airflow\", names=['foo'], module='bar'),\n... ).requirements\n{OrbiterRequirement(names=[foo], package=apache-airflow, module=bar, sys_package=None)}\n\n&gt;&gt;&gt; OrbiterProject().add_requirements(\n...    [OrbiterRequirement(package=\"apache-airflow\", names=['foo'], module='bar')],\n... ).requirements\n{OrbiterRequirement(names=[foo], package=apache-airflow, module=bar, sys_package=None)}\n</code></pre> <p>Tip</p> <p>Validation requires an <code>OrbiterRequirement</code> to be passed <pre><code>&gt;&gt;&gt; # noinspection PyTypeChecker\n... OrbiterProject().add_requirements('foo')\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n&gt;&gt;&gt; # noinspection PyTypeChecker\n&gt;&gt;&gt; OrbiterProject().add_requirements(['foo'])\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n</code></pre></p> <p>Parameters:</p> Name Type Description <code>requirements</code> <code>OrbiterRequirement | Iterable[OrbiterRequirement]</code> <p>List of OrbiterRequirement</p> <p>Returns:</p> Type Description <code>OrbiterProject</code> <p>self</p> Source code in <code>orbiter/objects/project.py</code> <pre><code>def add_requirements(self, requirements: OrbiterRequirement | Iterable[OrbiterRequirement]) -&gt; \"OrbiterProject\":\n    \"\"\"Add [OrbiterRequirement][orbiter.objects.requirement.OrbiterRequirement] to the Project\n    or override an existing requirement with new properties\n\n    ```pycon\n    &gt;&gt;&gt; OrbiterProject().add_requirements(\n    ...    OrbiterRequirement(package=\"apache-airflow\", names=['foo'], module='bar'),\n    ... ).requirements\n    {OrbiterRequirement(names=[foo], package=apache-airflow, module=bar, sys_package=None)}\n\n    &gt;&gt;&gt; OrbiterProject().add_requirements(\n    ...    [OrbiterRequirement(package=\"apache-airflow\", names=['foo'], module='bar')],\n    ... ).requirements\n    {OrbiterRequirement(names=[foo], package=apache-airflow, module=bar, sys_package=None)}\n\n    ```\n\n    !!! tip\n\n        Validation requires an `OrbiterRequirement` to be passed\n        ```pycon\n        &gt;&gt;&gt; # noinspection PyTypeChecker\n        ... OrbiterProject().add_requirements('foo')\n        ... # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        pydantic_core._pydantic_core.ValidationError: ...\n        &gt;&gt;&gt; # noinspection PyTypeChecker\n        &gt;&gt;&gt; OrbiterProject().add_requirements(['foo'])\n        ... # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        pydantic_core._pydantic_core.ValidationError: ...\n\n        ```\n    :param requirements: List of [OrbiterRequirement][orbiter.objects.requirement.OrbiterRequirement]\n    :type requirements: List[OrbiterRequirement] | OrbiterRequirement\n    :return: self\n    :rtype: OrbiterProject\n    \"\"\"\n    for requirement in [requirements] if isinstance(requirements, OrbiterRequirement) else requirements:\n        self.requirements.add(requirement)\n    return self\n</code></pre>"},{"location":"objects/project/#orbiter.objects.project.OrbiterProject.add_variables","title":"add_variables","text":"<pre><code>add_variables(\n    variables: OrbiterVariable | Iterable[OrbiterVariable],\n) -&gt; \"OrbiterProject\"\n</code></pre> <p>Add OrbiterVariables to the Project or override an existing variable with new properties</p> <pre><code>&gt;&gt;&gt; OrbiterProject().add_variables(OrbiterVariable(key=\"foo\", value=\"bar\")).variables\n{'foo': OrbiterVariable(key='foo', value='bar')}\n\n&gt;&gt;&gt; OrbiterProject().add_variables([OrbiterVariable(key=\"foo\", value=\"bar\")]).variables\n{'foo': OrbiterVariable(key='foo', value='bar')}\n</code></pre> <p>Tip</p> <p>Validation requires an <code>OrbiterVariable</code> to be passed <pre><code>&gt;&gt;&gt; # noinspection PyTypeChecker\n... OrbiterProject().add_variables('foo')\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n&gt;&gt;&gt; # noinspection PyTypeChecker\n... OrbiterProject().add_variables(['foo'])\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\npydantic_core._pydantic_core.ValidationError: ...\n</code></pre></p> <p>Parameters:</p> Name Type Description <code>variables</code> <code>OrbiterVariable | Iterable[OrbiterVariable]</code> <p>List of OrbiterVariable</p> <p>Returns:</p> Type Description <code>OrbiterProject</code> <p>self</p> Source code in <code>orbiter/objects/project.py</code> <pre><code>def add_variables(self, variables: OrbiterVariable | Iterable[OrbiterVariable]) -&gt; \"OrbiterProject\":\n    \"\"\"Add [OrbiterVariables][orbiter.objects.variable.OrbiterVariable] to the Project\n    or override an existing variable with new properties\n\n    ```pycon\n    &gt;&gt;&gt; OrbiterProject().add_variables(OrbiterVariable(key=\"foo\", value=\"bar\")).variables\n    {'foo': OrbiterVariable(key='foo', value='bar')}\n\n    &gt;&gt;&gt; OrbiterProject().add_variables([OrbiterVariable(key=\"foo\", value=\"bar\")]).variables\n    {'foo': OrbiterVariable(key='foo', value='bar')}\n\n    ```\n\n    !!! tip\n\n        Validation requires an `OrbiterVariable` to be passed\n        ```pycon\n        &gt;&gt;&gt; # noinspection PyTypeChecker\n        ... OrbiterProject().add_variables('foo')\n        ... # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        pydantic_core._pydantic_core.ValidationError: ...\n        &gt;&gt;&gt; # noinspection PyTypeChecker\n        ... OrbiterProject().add_variables(['foo'])\n        ... # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        pydantic_core._pydantic_core.ValidationError: ...\n\n        ```\n    :param variables: List of [OrbiterVariable][orbiter.objects.variable.OrbiterVariable]\n    :type variables: List[OrbiterVariable] | OrbiterVariable\n    :return: self\n    :rtype: OrbiterProject\n    \"\"\"\n    for variable in [variables] if isinstance(variables, OrbiterVariable) else variables:\n        self.variables[variable.key] = variable\n    return self\n</code></pre>"},{"location":"objects/project/#orbiter.objects.project.OrbiterProject.analyze","title":"analyze","text":"<pre><code>analyze(\n    output_fmt: Literal[\"json\", \"csv\", \"md\"] = \"md\",\n    output_file=None,\n)\n</code></pre> <p>Print an analysis of the project to the console.</p> <p>Tip</p> <p>Looks for a specific <code>[task_type=XYZ]</code> in the Task's <code>doc_md</code> property or uses <code>type(task)</code> to infer the type of task.</p> <pre><code>&gt;&gt;&gt; from orbiter.objects.operators.empty import OrbiterEmptyOperator\n&gt;&gt;&gt; OrbiterProject().add_dags([\n...     OrbiterDAG(file_path=\"\", dag_id=\"foo\", orbiter_kwargs={\"file_path\": \"foo.py\"},\n...         tasks={\"bar\": OrbiterEmptyOperator(task_id=\"bar\")}\n...     ),\n...     OrbiterDAG(file_path=\"\", dag_id=\"baz\", orbiter_kwargs={\"file_path\": \"baz.py\"},\n...         tasks={\"bop\": OrbiterEmptyOperator(task_id=\"bop\")}\n...     )\n... ]).analyze()\n... # doctest: +ELLIPSIS\n\u250f\u2501...\n...Analysis...\n\u2517\u2501...\n&lt;BLANKLINE&gt;\n&lt;BLANKLINE&gt;\n           DAGs   OrbiterEmptyOperator\n \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n  foo.py      1                      1\n  baz.py      1                      1\n  Totals      2                      2\n&lt;BLANKLINE&gt;\n</code></pre> Source code in <code>orbiter/objects/project.py</code> <pre><code>@validate_call\ndef analyze(self, output_fmt: Literal[\"json\", \"csv\", \"md\"] = \"md\", output_file=None):\n    \"\"\"Print an analysis of the project to the console.\n\n    !!! tip\n\n        Looks for a specific `[task_type=XYZ]` in the Task's `doc_md` property\n        or uses `type(task)` to infer the type of task.\n\n    ```pycon\n    &gt;&gt;&gt; from orbiter.objects.operators.empty import OrbiterEmptyOperator\n    &gt;&gt;&gt; OrbiterProject().add_dags([\n    ...     OrbiterDAG(file_path=\"\", dag_id=\"foo\", orbiter_kwargs={\"file_path\": \"foo.py\"},\n    ...         tasks={\"bar\": OrbiterEmptyOperator(task_id=\"bar\")}\n    ...     ),\n    ...     OrbiterDAG(file_path=\"\", dag_id=\"baz\", orbiter_kwargs={\"file_path\": \"baz.py\"},\n    ...         tasks={\"bop\": OrbiterEmptyOperator(task_id=\"bop\")}\n    ...     )\n    ... ]).analyze()\n    ... # doctest: +ELLIPSIS\n    \u250f\u2501...\n    ...Analysis...\n    \u2517\u2501...\n    &lt;BLANKLINE&gt;\n    &lt;BLANKLINE&gt;\n               DAGs   OrbiterEmptyOperator\n     \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n      foo.py      1                      1\n      baz.py      1                      1\n      Totals      2                      2\n    &lt;BLANKLINE&gt;\n\n    ```\n    \"\"\"\n    if output_file is None:\n        output_file = sys.stdout\n\n    _task_type = re.compile(r\"\\[task_type=(?P&lt;task_type&gt;[A-Za-z0-9-_]+)\")\n\n    def get_task_type(task):\n        match = _task_type.match(getattr(task, \"doc_md\", None) or \"\")\n        match_or_task_type = (match.groupdict().get(\"task_type\") if match else None) or type(task).__name__\n        return match_or_task_type\n\n    dag_analysis = [\n        {\n            \"file\": dag.orbiter_kwargs.get(\"file_path\", dag.file_path),\n            \"dag_id\": dag.dag_id,\n            \"task_types\": [get_task_type(task) for task in dag.tasks.values()],\n        }\n        for dag in self.dags.values()\n    ]\n\n    file_analysis = {}\n    for analysis in dag_analysis:\n        analysis_output = file_analysis.get(analysis[\"file\"], {})\n        analysis_output[\"DAGs\"] = analysis_output.get(\"DAGs\", 0) + 1\n        tasks_of_type = reduce(\n            lambda acc, task_type: acc | {task_type: acc.get(task_type, 0) + 1},\n            analysis[\"task_types\"],\n            dict(),\n        )\n        analysis_output |= tasks_of_type\n        file_analysis[analysis[\"file\"]] = analysis_output\n\n    file_analysis = [{\"\": k} | v for k, v in file_analysis.items()]\n    totals = {\"\": \"Totals\"}\n    for file in file_analysis:\n        for k, v in file.items():\n            if k != \"\":\n                totals[k] = totals.get(k, 0) + v\n    file_analysis.append(totals)\n\n    if output_fmt == \"json\":\n        import json\n\n        json.dump(file_analysis, output_file, default=str)\n    elif output_fmt == \"csv\":\n        import csv\n\n        writer = csv.DictWriter(output_file, fieldnames={\"\"} | totals.keys())\n        writer.writeheader()\n        writer.writerows(file_analysis)\n    elif output_fmt == \"md\":\n        from rich.console import Console\n        from rich.markdown import Markdown\n        from tabulate import tabulate\n\n        console = Console(file=output_file)\n\n        #         DAGs  EmptyOp\n        # file_a     1        1\n        table = tabulate(\n            tabular_data=file_analysis,\n            headers=\"keys\",\n            tablefmt=\"pipe\",\n            # https://github.com/Textualize/rich/issues/3027\n            missingval=\"\u2800\",  # (special 'braille space' character)\n        )\n        console.print(\n            Markdown(\n                f\"# Analysis\\n{table}\",\n                style=\"magenta\",\n            )\n        )\n</code></pre>"},{"location":"objects/workflow/","title":"Workflow","text":"<p>Airflow workflows are represented by a DAG which is a Directed Acyclic Graph (of Tasks).</p>"},{"location":"objects/workflow/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    direction LR\n    class OrbiterRequirement[\"orbiter.objects.requirement.OrbiterRequirement\"] {\n            package: str | None\n            module: str | None\n            names: List[str] | None\n            sys_package: str | None\n    }\n\n    OrbiterDAG \"via schedule\" --&gt; OrbiterTimetable\n    OrbiterDAG --&gt; \"many\" OrbiterOperator\n    OrbiterDAG --&gt; \"many\" OrbiterTaskGroup\n    OrbiterDAG --&gt; \"many\" OrbiterRequirement\n    class OrbiterDAG[\"orbiter.objects.dag.OrbiterDAG\"] {\n            imports: List[OrbiterRequirement]\n            file_path: str\n            dag_id: str\n            schedule: str | OrbiterTimetable | None\n            catchup: bool\n            start_date: DateTime\n            tags: List[str]\n            default_args: Dict[str, Any]\n            params: Dict[str, Any]\n            doc_md: str | None\n            tasks: Dict[str, OrbiterOperator]\n            kwargs: dict\n            orbiter_kwargs: dict\n            orbiter_conns: Set[OrbiterConnection]\n            orbiter_vars: Set[OrbiterVariable]\n            orbiter_env_vars: Set[OrbiterEnvVar]\n            orbiter_includes: Set[OrbiterInclude]\n    }\n    click OrbiterDAG href \"#orbiter.objects.dag.OrbiterDAG\" \"OrbiterDAG Documentation\"\n\n    OrbiterTaskGroup --&gt; \"many\" OrbiterRequirement\n    class OrbiterTaskGroup[\"orbiter.objects.task.OrbiterTaskGroup\"] {\n            task_group_id: str\n            tasks: Dict[str, OrbiterOperator | OrbiterTaskGroup]\n            add_downstream(str | List[str] | OrbiterTaskDependency)\n    }\n\n    OrbiterOperator --&gt; \"many\" OrbiterRequirement\n    OrbiterOperator --&gt; \"one\" OrbiterPool\n    OrbiterOperator --&gt; \"many\" OrbiterConnection\n    OrbiterOperator --&gt; \"many\" OrbiterVariable\n    OrbiterOperator --&gt; \"many\" OrbiterEnvVar\n    class OrbiterOperator[\"orbiter.objects.task.OrbiterOperator\"] {\n            imports: List[OrbiterRequirement]\n            operator: str\n            task_id: str\n            pool: str | None\n            pool_slots: int | None\n            trigger_rule: str | None\n            downstream: Set[str]\n            add_downstream(str | List[str] | OrbiterTaskDependency)\n    }\n\n    class OrbiterTimetable[\"orbiter.objects.timetables.OrbiterTimetable\"] {\n            imports: List[OrbiterRequirement]\n            orbiter_includes: Set[OrbiterIncludes]\n            **kwargs: dict\n    }\n    click OrbiterTimetable href \"#orbiter.objects.timetables.OrbiterTimetable\" \"OrbiterTimetable Documentation\"\n\n    class OrbiterConnection[\"orbiter.objects.connection.OrbiterConnection\"] {\n            conn_id: str\n            conn_type: str\n            **kwargs\n    }\n\n    class OrbiterEnvVar[\"orbiter.objects.env_var.OrbiterEnvVar\"] {\n            key: str\n            value: str\n    }\n\n    class OrbiterPool[\"orbiter.objects.pool.OrbiterPool\"] {\n            name: str\n            description: str | None\n            slots: int | None\n    }\n\n    class OrbiterRequirement[\"orbiter.objects.requirement.OrbiterRequirement\"] {\n            package: str | None\n            module: str | None\n            names: List[str] | None\n            sys_package: str | None\n    }\n\n    class OrbiterVariable[\"orbiter.objects.variable.OrbiterVariable\"] {\n            key: str\n            value: str\n    }</code></pre>"},{"location":"objects/workflow/#orbiter.objects.dag.OrbiterDAG","title":"orbiter.objects.dag.OrbiterDAG","text":"<p>Represents an Airflow DAG, with its tasks and dependencies.</p> <p>Renders to a <code>.py</code> file in the <code>/dags</code> folder</p> <p>Parameters:</p> Name Type Description <code>file_path</code> <code>str</code> <p>File path of the DAG, relative to the <code>/dags</code> folder (<code>filepath=my_dag.py</code> would render to <code>dags/my_dag.py</code>)</p> <code>dag_id</code> <code>str</code> <p>The <code>dag_id</code>. Must be unique and snake_case. Good practice is to set <code>dag_id</code> == <code>file_path</code></p> <code>schedule</code> <code>str | OrbiterTimetable, optional</code> <p>The schedule for the DAG. Defaults to None (only runs when manually triggered)</p> <code>catchup</code> <code>bool, optional</code> <p>Whether to catchup runs from the <code>start_date</code> to now, on first run. Defaults to False</p> <code>start_date</code> <code>DateTime, optional</code> <p>The start date for the DAG. Defaults to Unix Epoch</p> <code>tags</code> <code>List[str], optional</code> <p>Tags for the DAG, used for sorting and filtering in the Airflow UI</p> <code>default_args</code> <code>Dict[str, Any], optional</code> <p>Default arguments for any tasks in the DAG</p> <code>params</code> <code>Dict[str, Any], optional</code> <p>Params for the DAG</p> <code>doc_md</code> <code>str, optional</code> <p>Documentation for the DAG with markdown support</p> <code>kwargs</code> <code>dict, optional</code> <p>Additional keyword arguments to pass to the DAG</p> <code>**OrbiterBase</code> <p>OrbiterBase inherited properties</p>"},{"location":"objects/workflow/#timetables","title":"Timetables","text":"<p>Modules:</p> Name Description <code>multi_cron_timetable</code> <p>Classes:</p> Name Description <code>OrbiterTimetable</code> <p>An Airflow Timetable</p>"},{"location":"objects/workflow/#orbiter.objects.timetables.OrbiterTimetable","title":"orbiter.objects.timetables.OrbiterTimetable","text":"<p>An Airflow Timetable reference.</p> <p>Utilizes <code>OrbiterInclude</code> to add a file to a /plugins folder to register the timetable.</p> <p>Parameters:</p> Name Type Description <code>**kwargs</code> <p>any other kwargs to provide to Timetable</p>"},{"location":"objects/workflow/#orbiter.objects.timetables.multi_cron_timetable","title":"orbiter.objects.timetables.multi_cron_timetable","text":"<p>Classes:</p> Name Description <code>OrbiterMultiCronTimetable</code> <p>An</p>"},{"location":"objects/workflow/#orbiter.objects.timetables.multi_cron_timetable.OrbiterMultiCronTimetable","title":"orbiter.objects.timetables.multi_cron_timetable.OrbiterMultiCronTimetable","text":"<p>An Airflow Timetable that can be supplied with multiple cron strings.</p> <pre><code>&gt;&gt;&gt; OrbiterMultiCronTimetable(cron_defs=[\"*/5 * * * *\", \"*/7 * * * *\"])\nMultiCronTimetable(cron_defs=['*/5 * * * *', '*/7 * * * *'])\n</code></pre> <p>Parameters:</p> Name Type Description <code>cron_defs</code> <code>List[str]</code> <p>A list of cron strings</p> <code>timezone</code> <code>str</code> <p>The timezone to use for the timetable</p> <code>period_length</code> <code>int</code> <p>The length of the period</p> <code>period_unit</code> <code>str</code> <p>The unit of the period</p>"},{"location":"objects/Tasks/","title":"Overview","text":"<p>Airflow Tasks are units of work. An Operator is a pre-defined task with specific functionality.</p> <p>Operators can be looked up in the Astronomer Registry.</p> <p>The easiest way to create an operator in a translation to use an existing subclass of <code>OrbiterOperator</code> (e.g. <code>OrbiterBashOperator</code>).</p> <p>If an <code>OrbiterOperator</code> subclass doesn't exist for your use case, you can:</p> <p>1) Utilize <code>OrbiterTask</code> <pre><code>from orbiter.objects.requirement import OrbiterRequirement\nfrom orbiter.objects.task import OrbiterTask\nfrom orbiter.rules import task_rule\n\n@task_rule\ndef my_rule(val: dict):\n    return OrbiterTask(\n        task_id=\"my_task\",\n        imports=[OrbiterRequirement(\n            package=\"apache-airflow\",\n            module=\"airflow.operators.trigger_dagrun\",\n            names=[\"TriggerDagRunOperator\"],\n        )],\n        ...\n    )\n</code></pre></p> <p>2) Create a new subclass of <code>OrbiterOperator</code>, which can be beneficial if you are using it frequently    in separate <code>@task_rules</code> <pre><code>from orbiter.objects.task import OrbiterOperator\nfrom orbiter.objects.requirement import OrbiterRequirement\nfrom orbiter.rules import task_rule\n\nclass OrbiterTriggerDagRunOperator(OrbiterOperator):\n    # Define the imports required for the operator, and the operator name\n    imports = [\n        OrbiterRequirement(\n            package=\"apache-airflow\",\n            module=\"airflow.operators.trigger_dagrun\",\n            names=[\"TriggerDagRunOperator\"],\n        )\n    ]\n    operator: str = \"PythonOperator\"\n\n    # Add fields should be rendered in the output\n    render_attributes = OrbiterOperator.render_attributes + [\n        ...\n    ]\n\n    # Add the fields that are required for the operator here, with their types\n    # Not all Airflow Operator fields are required, just the ones you will use.\n    trigger_dag_id: str\n    ...\n\n@task_rule\ndef my_rule(val: dict):\n    return OrbiterTriggerDagRunOperator(...)\n</code></pre></p>"},{"location":"objects/Tasks/#diagram","title":"Diagram","text":"<pre><code>classDiagram\n    direction LR\n    OrbiterOperator \"implements\" &lt;|-- OrbiterTask\n    OrbiterOperator --&gt; \"many\" OrbiterCallback\n    class OrbiterOperator[\"orbiter.objects.task.OrbiterOperator\"] {\n            imports: List[OrbiterRequirement]\n            operator: str\n            task_id: str\n            pool: str | None\n            pool_slots: int | None\n            trigger_rule: str | None\n            downstream: Set[str]\n            add_downstream(str | List[str] | OrbiterTaskDependency)\n    }\n    click OrbiterOperator href \"#orbiter.objects.task.OrbiterOperator\" \"OrbiterOperator Documentation\"\n\n    class OrbiterTask[\"orbiter.objects.task.OrbiterTask\"] {\n        &lt;&lt;OrbiterOperator&gt;&gt;\n            &lt;&lt;OrbiterOperator&gt;&gt;\n            imports: List[OrbiterRequirement]\n            task_id: str\n            **kwargs\n    }\n    click OrbiterTask href \"#orbiter.objects.task.OrbiterTask\" \"OrbiterTask Documentation\"\n\n    OrbiterOperator \"implements\" &lt;|-- OrbiterBashOperator\n    class OrbiterBashOperator[\"orbiter.objects.operators.bash.OrbiterBashOperator\"] {\n        &lt;&lt;OrbiterOperator&gt;&gt;\n            operator = \"BashOperator\"\n            task_id: str\n            bash_command: str\n    }\n    click OrbiterBashOperator href \"Operators_and_Callbacks/operators#orbiter.objects.operators.bash.OrbiterBashOperator\" \"OrbiterBashOperator Documentation\"\n\n    OrbiterOperator \"implements\" &lt;|-- OrbiterEmailOperator\n    class OrbiterEmailOperator[\"orbiter.objects.operators.smtp.OrbiterEmailOperator\"] {\n        &lt;&lt;OrbiterOperator&gt;&gt;\n            operator = \"EmailOperator\"\n            task_id: str\n            to: str | list[str]\n            subject: str\n            html_content: str\n            files: list | None\n            conn_id: str\n    }\n    click OrbiterEmailOperator href \"Operators_and_Callbacks/operators#orbiter.objects.operators.smtp.OrbiterEmailOperator\" \"OrbiterEmailOperator Documentation\"\n\n  OrbiterOperator  \"implements\" &lt;|--  OrbiterEmptyOperator\n    class OrbiterEmptyOperator[\"orbiter.objects.operators.empty.OrbiterEmptyOperator\"] {\n        &lt;&lt;OrbiterOperator&gt;&gt;\n            operator = \"BashOperator\"\n            task_id: str\n    }\n    click OrbiterEmptyOperator href \"Operators_and_Callbacks/operators#orbiter.objects.operators.empty.OrbiterEmptyOperator\" \"OrbiterEmptyOperator Documentation\"\n\n    OrbiterOperator \"implements\" &lt;|-- OrbiterPythonOperator\n    class OrbiterPythonOperator[\"orbiter.objects.operators.python.OrbiterPythonOperator\"] {\n        &lt;&lt;OrbiterOperator&gt;&gt;\n            operator = \"PythonOperator\"\n            task_id: str\n            python_callable: Callable\n            op_args: list | None\n            op_kwargs: dict | None\n    }\n    click OrbiterPythonOperator href \"Operators_and_Callbacks/operators#orbiter.objects.operators.python.OrbiterPythonOperator\" \"OrbiterPythonOperator Documentation\"\n\n    OrbiterOperator \"implements\" &lt;|-- OrbiterSQLExecuteQueryOperator\n    class OrbiterSQLExecuteQueryOperator[\"orbiter.objects.operators.sql.OrbiterSQLExecuteQueryOperator\"] {\n        &lt;&lt;OrbiterOperator&gt;&gt;\n            operator = \"SQLExecuteQueryOperator\"\n            task_id: str\n            conn_id: str\n            sql: str | list[str]\n    }\n    click OrbiterSQLExecuteQueryOperator href \"Operators_and_Callbacks/operators#orbiter.objects.operators.sql.OrbiterSQLExecuteQueryOperator\" \"OrbiterSQLExecuteQueryOperator Documentation\"\n\n    OrbiterOperator \"implements\" &lt;|-- OrbiterSSHOperator\n    class OrbiterSSHOperator[\"orbiter.objects.operators.ssh.OrbiterSSHOperator\"] {\n        &lt;&lt;OrbiterOperator&gt;&gt;\n            operator = \"SSHOperator\"\n            task_id: str\n            ssh_conn_id: str\n            command: str\n            environment: Dict[str, str] | None\n    }\n    click OrbiterSSHOperator href \"Operators_and_Callbacks/operators#orbiter.objects.operators.ssh.OrbiterSSHOperator\" \"OrbiterSSHOperator Documentation\"\n\n    class OrbiterCallback[\"orbiter.objects.callbacks.OrbiterCallback\"] {\n            function: str\n    }\n    click OrbiterCallback href \"Operators_and_Callbacks/callbacks#orbiter.objects.callbacks.OrbiterCallback\" \"OrbiterCallback Documentation\"\n\n    OrbiterCallback \"implements\" &lt;|--  OrbiterSmtpNotifierCallback\n    class OrbiterSmtpNotifierCallback[\"orbiter.objects.callbacks.smtp.OrbiterSmtpNotifierCallback\"] {\n        &lt;&lt;OrbiterCallback&gt;&gt;\n            to: str\n            from_email: str\n            smtp_conn_id: str\n            subject: str\n            html_content: str\n            cc: str | Sequence[str]\n    }\n    click OrbiterSmtpNotifierCallback href \"Operators_and_Callbacks/callbacks#orbiter.objects.callbacks.smtp.OrbiterSmtpNotifierCallback\" \"OrbiterSmtpNotifierCallback Documentation\"</code></pre>"},{"location":"objects/Tasks/#orbiter.objects.task.OrbiterOperator","title":"orbiter.objects.task.OrbiterOperator","text":"<p>Abstract class representing a Task in Airflow.</p> <p>Must be subclassed (such as <code>OrbiterBashOperator</code>, or <code>OrbiterTask</code>).</p> <p>Subclassing Example: <pre><code>&gt;&gt;&gt; from orbiter.objects import OrbiterRequirement\n&gt;&gt;&gt; class OrbiterMyOperator(OrbiterOperator):\n...   imports: ImportList = [OrbiterRequirement(package=\"apache-airflow\")]\n...   operator: str = \"MyOperator\"\n\n&gt;&gt;&gt; foo = OrbiterMyOperator(task_id=\"task_id\"); foo\ntask_id_task = MyOperator(task_id='task_id')\n</code></pre></p> <p>Adding single downstream tasks: <pre><code>&gt;&gt;&gt; from orbiter.ast_helper import render_ast\n&gt;&gt;&gt; render_ast(foo.add_downstream(\"downstream\")._downstream_to_ast())\n'task_id_task &gt;&gt; downstream_task'\n</code></pre></p> <p>Adding multiple downstream tasks: <pre><code>&gt;&gt;&gt; render_ast(foo.add_downstream([\"a\", \"b\"])._downstream_to_ast())\n'task_id_task &gt;&gt; [a_task, b_task, downstream_task]'\n</code></pre></p> <p>Note</p> <p>Validation - task_id in OrbiterTaskDependency must match this task_id <pre><code>&gt;&gt;&gt; foo.add_downstream(OrbiterTaskDependency(task_id=\"other\", downstream=\"bar\")).downstream\n... # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nValueError: Task dependency ... has a different task_id than task_id\n</code></pre></p> <p>Parameters:</p> Name Type Description <code>imports</code> <code>List[OrbiterRequirement]</code> <p>List of requirements for the operator</p> <code>task_id</code> <code>str</code> <p>The <code>task_id</code> for the operator, must be unique and snake_case</p> <code>trigger_rule</code> <code>str, optional</code> <p>Conditions under which to start the task (docs)</p> <code>pool</code> <code>str, optional</code> <p>Name of the pool to use</p> <code>pool_slots</code> <code>int, optional</code> <p>Slots for this task to occupy</p> <code>operator</code> <code>str, optional</code> <p>Operator name</p> <code>downstream</code> <code>Set[str], optional</code> <p>Downstream tasks, defaults to <code>set()</code></p> <code>**kwargs</code> <p>Other properties that may be passed to operator</p> <code>**OrbiterBase</code> <p>OrbiterBase inherited properties</p>"},{"location":"objects/Tasks/#orbiter.objects.task.OrbiterTaskDependency","title":"orbiter.objects.task.OrbiterTaskDependency","text":"<p>Represents a task dependency, which is added to either an <code>OrbiterOperator</code> or an <code>OrbiterTaskGroup</code>.</p> <p>Parameters:</p> Name Type Description <code>task_id</code> <code>str</code> <p>The task_id for the operator</p> <code>downstream</code> <code>str | List[str]</code> <p>downstream task(s)</p>"},{"location":"objects/Tasks/#orbiter.objects.task.OrbiterTask","title":"orbiter.objects.task.OrbiterTask","text":"<p>A generic version of <code>OrbiterOperator</code> that can be instantiated directly.</p> <p>The operator that is instantiated is inferred from the <code>imports</code> field, via the first <code>*Operator</code> or <code>*Sensor</code> import.</p> <p>View info for specific operators at the Astronomer Registry.</p> <pre><code>&gt;&gt;&gt; from orbiter.objects.requirement import OrbiterRequirement\n&gt;&gt;&gt; OrbiterTask(task_id=\"foo\", bash_command=\"echo 'hello world'\", other=1, imports=[\n...   OrbiterRequirement(package=\"apache-airflow\", module=\"airflow.operators.bash\", names=[\"BashOperator\"])\n... ])\nfoo_task = BashOperator(task_id='foo', bash_command=\"echo 'hello world'\", other=1)\n\n&gt;&gt;&gt; def foo():\n...   pass\n&gt;&gt;&gt; OrbiterTask(task_id=\"foo\", python_callable=foo, other=1, imports=[\n...   OrbiterRequirement(package=\"apache-airflow\", module=\"airflow.sensors.python\", names=[\"PythonSensor\"])\n... ])\ndef foo():\n    pass\nfoo_task = PythonSensor(task_id='foo', other=1, python_callable=foo)\n</code></pre> <p>Parameters:</p> Name Type Description <code>task_id</code> <code>str</code> <p>The <code>task_id</code> for the operator. Must be unique and snake_case</p> <code>imports</code> <code>List[OrbiterRequirement]</code> <p>List of requirements for the operator. The Operator is inferred from first <code>*Operator</code> or <code>*Sensor</code> imported.</p> <code>**kwargs</code> <p>Any other keyword arguments to be passed to the operator</p>"},{"location":"objects/Tasks/#orbiter.objects.task_group.OrbiterTaskGroup","title":"orbiter.objects.task_group.OrbiterTaskGroup","text":"<p>Represents a TaskGroup in Airflow, which contains multiple tasks</p> <pre><code>&gt;&gt;&gt; from orbiter.objects.operators.bash import OrbiterBashOperator\n&gt;&gt;&gt; from orbiter.ast_helper import render_ast\n&gt;&gt;&gt; OrbiterTaskGroup(task_group_id=\"foo\").add_tasks([\n...   OrbiterBashOperator(task_id=\"b\", bash_command=\"b\"),\n...   OrbiterBashOperator(task_id=\"a\", bash_command=\"a\").add_downstream(\"b\"),\n... ]).add_downstream(\"c\")\nwith TaskGroup(group_id='foo') as foo:\n    b_task = BashOperator(task_id='b', bash_command='b')\n    a_task = BashOperator(task_id='a', bash_command='a')\n    a_task &gt;&gt; b_task\n\n&gt;&gt;&gt; render_ast(OrbiterTaskGroup(task_group_id=\"foo\", downstream={\"c\"})._downstream_to_ast())\n'foo &gt;&gt; c_task'\n</code></pre> <p>Parameters:</p> Name Type Description <code>task_group_id</code> <code>str</code> <p>The id of the TaskGroup</p> <code>tasks</code> <code>Dict[str, OrbiterOperator | OrbiterTaskGroup]</code> <p>The tasks in the TaskGroup</p> <code>**OrbiterBase</code> <p>OrbiterBase inherited properties</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/callbacks/","title":"Callbacks","text":"<p>Airflow callback functions are often used to send emails, slack messages, or other notifications when a task fails, succeeds, or is retried. They can also run any general Python function.</p> <p>Modules:</p> Name Description <code>smtp</code> <p>Classes:</p> Name Description <code>OrbiterCallback</code> <p>Represents an Airflow</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/callbacks/#orbiter.objects.callbacks.OrbiterCallback","title":"orbiter.objects.callbacks.OrbiterCallback","text":"<p>Represents an Airflow callback function, which might be used in <code>DAG.on_failure_callback</code>, or <code>Task.on_success_callback</code>, or etc.</p> <p>Can be instantiated directly as a bare callback function (with no arguments): <pre><code>&gt;&gt;&gt; from orbiter.objects.dag import OrbiterDAG\n&gt;&gt;&gt; from orbiter.objects.include import OrbiterInclude\n&gt;&gt;&gt; my_callback = OrbiterCallback(\n...     function=\"my_callback\",\n...     imports=[OrbiterRequirement(module=\"my_callback\", names=[\"my_callback\"])],\n...     orbiter_includes={OrbiterInclude(filepath=\"my_callback.py\", contents=\"...\")}\n... )\n&gt;&gt;&gt; OrbiterDAG(dag_id='', file_path='', on_failure_callback=my_callback)\n... # doctest: +ELLIPSIS\nfrom airflow import DAG\nfrom my_callback import my_callback\n...\nwith DAG(... on_failure_callback=my_callback):\n</code></pre></p> <p>or be subclassed: <pre><code>&gt;&gt;&gt; class OrbiterMyCallback(OrbiterCallback):\n...   function: str = \"my_callback\"\n...   foo: str\n...   bar: str\n...   render_attributes: RenderAttributes = [\"foo\", \"bar\"]\n&gt;&gt;&gt; OrbiterMyCallback(foo=\"fop\", bar=\"bop\")\nmy_callback(foo='fop', bar='bop')\n</code></pre></p> <p>Parameters:</p> Name Type Description <code>function</code> <code>str</code> <p>The name of the function to call</p> <code>**OrbiterBase</code> <p>OrbiterBase inherited properties</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/callbacks/#orbiter.objects.callbacks.smtp","title":"orbiter.objects.callbacks.smtp","text":"<p>Classes:</p> Name Description <code>OrbiterSmtpNotifierCallback</code> <p>An Airflow SMTP Callback</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/callbacks/#orbiter.objects.callbacks.smtp.OrbiterSmtpNotifierCallback","title":"orbiter.objects.callbacks.smtp.OrbiterSmtpNotifierCallback","text":"<p>An Airflow SMTP Callback</p> <p>Note</p> <p>Use <code>smtp_conn_id</code> and reference an SMTP Connection.</p> <p>You can use the <code>**conn_id(\"SMTP\", conn_type=\"smtp\")</code> utility function to set both properties at once.</p> <pre><code>&gt;&gt;&gt; [_import] = OrbiterSmtpNotifierCallback(to=\"foo@test.com\").imports; _import\nOrbiterRequirement(names=[send_smtp_notification], package=apache-airflow-providers-smtp, module=airflow.providers.smtp.notifications.smtp, sys_package=None)\n&gt;&gt;&gt; OrbiterSmtpNotifierCallback(to=\"foo@test.com\", from_email=\"bar@test.com\", subject=\"Hello\", html_content=\"World\")\nsend_smtp_notification(to='foo@test.com', from_email='bar@test.com', smtp_conn_id='SMTP', subject='Hello', html_content='World')\n&gt;&gt;&gt; OrbiterSmtpNotifierCallback(to=[\"foo@test.com\", \"baz@test.com\"], from_email=\"bar@test.com\", subject=\"Hello\", html_content=\"World\")\nsend_smtp_notification(to=['foo@test.com', 'baz@test.com'], from_email='bar@test.com', smtp_conn_id='SMTP', subject='Hello', html_content='World')\n</code></pre> <p>Parameters:</p> Name Type Description <code>to</code> <code>str | Sequence[str]</code> <p>The email address to send to</p> <code>from_email</code> <code>str, optional</code> <p>The email address to send from</p> <code>smtp_conn_id</code> <code>str, optional</code> <p>The connection id to use (Note: use the <code>**conn_id(...)</code> utility function). Defaults to \"SMTP\"</p> <code>subject</code> <code>str, optional</code> <p>The subject of the email</p> <code>html_content</code> <code>str, optional</code> <p>The content of the email</p> <code>cc</code> <code>str | Sequence[str], optional</code> <p>The email address to cc</p> <code>**OrbiterBase</code> <p>OrbiterBase inherited properties</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/operators/","title":"Operators","text":"<p>Note</p> <p>These operators are included and are intended to represent some of the most common Airflow Operators, but not all Airflow Operators.</p> <p>Additional Operators can be created by subclassing <code>OrbiterOperator</code> or using <code>OrbiterTask</code> directly.</p> <p>Review the Astronomer Registry to find additional Airflow Operators.</p> <p>Modules:</p> Name Description <code>bash</code> <code>empty</code> <code>python</code> <code>smtp</code> <code>sql</code> <code>ssh</code>"},{"location":"objects/Tasks/Operators_and_Callbacks/operators/#orbiter.objects.operators.bash","title":"orbiter.objects.operators.bash","text":"<p>Classes:</p> Name Description <code>OrbiterBashOperator</code> <p>An Airflow</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/operators/#orbiter.objects.operators.bash.OrbiterBashOperator","title":"orbiter.objects.operators.bash.OrbiterBashOperator","text":"<p>               Bases: <code>OrbiterOperator</code></p> <p>An Airflow BashOperator. Used to run shell commands.</p> <pre><code>&gt;&gt;&gt; OrbiterBashOperator(task_id=\"foo\", bash_command=\"echo 'hello world'\")\nfoo_task = BashOperator(task_id='foo', bash_command=\"echo 'hello world'\")\n</code></pre> <p>Parameters:</p> Name Type Description <code>task_id</code> <code>str</code> <p>The <code>task_id</code> for the operator</p> <code>bash_command</code> <code>str</code> <p>The shell command to execute</p> <code>**kwargs</code> <p>Extra arguments to pass to the operator</p> <code>**OrbiterBase</code> <p>OrbiterBase inherited properties</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/operators/#orbiter.objects.operators.empty","title":"orbiter.objects.operators.empty","text":"<p>Classes:</p> Name Description <code>OrbiterEmptyOperator</code> <p>An Airflow EmptyOperator. Does nothing.</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/operators/#orbiter.objects.operators.empty.OrbiterEmptyOperator","title":"orbiter.objects.operators.empty.OrbiterEmptyOperator","text":"<p>               Bases: <code>OrbiterOperator</code></p> <p>An Airflow EmptyOperator. Does nothing.</p> <pre><code>&gt;&gt;&gt; OrbiterEmptyOperator(task_id=\"foo\")\nfoo_task = EmptyOperator(task_id='foo')\n</code></pre> <p>Parameters:</p> Name Type Description <code>task_id</code> <code>str</code> <p>The <code>task_id</code> for the operator</p> <code>**kwargs</code> <p>Extra arguments to pass to the operator</p> <code>**OrbiterBase</code> <p>OrbiterBase inherited properties</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/operators/#orbiter.objects.operators.python","title":"orbiter.objects.operators.python","text":"<p>Classes:</p> Name Description <code>OrbiterPythonOperator</code> <p>An Airflow</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/operators/#orbiter.objects.operators.python.OrbiterPythonOperator","title":"orbiter.objects.operators.python.OrbiterPythonOperator","text":"<p>               Bases: <code>OrbiterOperator</code></p> <p>An Airflow PythonOperator. Used to execute any Python Function.</p> <pre><code>&gt;&gt;&gt; def foo(a, b):\n...    print(a + b)\n&gt;&gt;&gt; OrbiterPythonOperator(task_id=\"foo\", python_callable=foo)\ndef foo(a, b):\n   print(a + b)\nfoo_task = PythonOperator(task_id='foo', python_callable=foo)\n</code></pre> <p>You can utilize the <code>orbiter_includes</code> and <code>imports</code> to include additional Python code and imports (or subclass to default). <pre><code>&gt;&gt;&gt; from orbiter.objects.include import OrbiterInclude\n&gt;&gt;&gt; OrbiterPythonOperator(\n...     task_id=\"foo\",\n...     orbiter_includes={OrbiterInclude(filepath=\"include/bar.py\", contents=\"def baz(): pass\")},\n...     imports=[OrbiterRequirement(module=\"include.bar\", names=[\"baz\"])],\n...     python_callable=\"baz\"\n... )\nfoo_task = PythonOperator(task_id='foo', python_callable=baz)\n</code></pre></p> <p>Parameters:</p> Name Type Description <code>task_id</code> <code>str</code> <p>The <code>task_id</code> for the operator</p> <code>python_callable</code> <code>Callable</code> <p>The python function to execute</p> <code>op_args</code> <code>list | None, optional</code> <p>The arguments to pass to the python function, defaults to None</p> <code>op_kwargs</code> <code>dict | None, optional</code> <p>The keyword arguments to pass to the python function, defaults to None</p> <code>**kwargs</code> <p>Extra arguments to pass to the operator</p> <code>**OrbiterBase</code> <p>OrbiterBase inherited properties</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/operators/#orbiter.objects.operators.smtp","title":"orbiter.objects.operators.smtp","text":"<p>Classes:</p> Name Description <code>OrbiterEmailOperator</code> <p>An Airflow</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/operators/#orbiter.objects.operators.smtp.OrbiterEmailOperator","title":"orbiter.objects.operators.smtp.OrbiterEmailOperator","text":"<p>               Bases: <code>OrbiterOperator</code></p> <p>An Airflow EmailOperator. Used to send emails.</p> <pre><code>&gt;&gt;&gt; OrbiterEmailOperator(\n...   task_id=\"foo\", to=\"humans@astronomer.io\", subject=\"Hello\", html_content=\"World!\"\n... )\nfoo_task = EmailOperator(task_id='foo', to='humans@astronomer.io', subject='Hello', html_content='World!', conn_id='SMTP')\n</code></pre> <p>Parameters:</p> Name Type Description <code>task_id</code> <code>str</code> <p>The <code>task_id</code> for the operator</p> <code>to</code> <code>str | list[str]</code> <p>The recipient of the email</p> <code>subject</code> <code>str</code> <p>The subject of the email</p> <code>html_content</code> <code>str</code> <p>The content of the email</p> <code>files</code> <code>list, optional</code> <p>The files to attach to the email, defaults to None</p> <code>conn_id</code> <code>str, optional</code> <p>The SMTP connection to use. Defaults to \"SMTP\" and sets <code>orbiter_conns</code> property</p> <code>**kwargs</code> <p>Extra arguments to pass to the operator</p> <code>**OrbiterBase</code> <p>OrbiterBase inherited properties</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/operators/#orbiter.objects.operators.sql","title":"orbiter.objects.operators.sql","text":"<p>Classes:</p> Name Description <code>OrbiterSQLExecuteQueryOperator</code> <p>An Airflow</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/operators/#orbiter.objects.operators.sql.OrbiterSQLExecuteQueryOperator","title":"orbiter.objects.operators.sql.OrbiterSQLExecuteQueryOperator","text":"<p>               Bases: <code>OrbiterOperator</code></p> <p>An Airflow Generic SQL Operator. Used to run SQL against any Database.</p> <pre><code>&gt;&gt;&gt; OrbiterSQLExecuteQueryOperator(\n...   task_id=\"foo\", conn_id='sql', sql=\"select 1;\"\n... )\nfoo_task = SQLExecuteQueryOperator(task_id='foo', conn_id='sql', sql='select 1;')\n</code></pre> <p>Parameters:</p> Name Type Description <code>task_id</code> <code>str</code> <p>The <code>task_id</code> for the operator</p> <code>conn_id</code> <code>str</code> <p>The SQL connection to utilize.  (Note: use the <code>**conn_id(...)</code> utility function)</p> <code>sql</code> <code>str | list[str]</code> <p>The SQL to execute</p> <code>**kwargs</code> <p>Extra arguments to pass to the operator</p> <code>**OrbiterBase</code> <p>OrbiterBase inherited properties</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/operators/#orbiter.objects.operators.ssh","title":"orbiter.objects.operators.ssh","text":"<p>Classes:</p> Name Description <code>OrbiterSSHOperator</code> <p>An Airflow</p>"},{"location":"objects/Tasks/Operators_and_Callbacks/operators/#orbiter.objects.operators.ssh.OrbiterSSHOperator","title":"orbiter.objects.operators.ssh.OrbiterSSHOperator","text":"<p>               Bases: <code>OrbiterOperator</code></p> <p>An Airflow SSHOperator. Used to run shell commands over SSH.</p> <pre><code>&gt;&gt;&gt; OrbiterSSHOperator(task_id=\"foo\", ssh_conn_id=\"SSH\", command=\"echo 'hello world'\")\nfoo_task = SSHOperator(task_id='foo', ssh_conn_id='SSH', command=\"echo 'hello world'\")\n</code></pre> <p>Parameters:</p> Name Type Description <code>task_id</code> <code>str</code> <p>The <code>task_id</code> for the operator</p> <code>ssh_conn_id</code> <code>str</code> <p>The SSH connection to use. (Note: use the <code>**conn_id(...)</code> utility function)</p> <code>command</code> <code>str</code> <p>The command to execute</p> <code>environment</code> <code>dict, optional</code> <p>The environment variables to set, defaults to None</p> <code>**kwargs</code> <p>Extra arguments to pass to the operator</p> <code>**OrbiterBase</code> <p>OrbiterBase inherited properties</p>"}]}